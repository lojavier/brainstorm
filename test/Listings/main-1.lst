C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_1
OBJECT MODULE PLACED IN .\Objects\main-1.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Objects\main-1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\main-1.lst) TABS(2) OBJECT(.\Objects\main-1.obj)

line level    source

   1          #include <c8051f120.h>
   2          #include <stdio.h>
   3          #include <math.h>
   4          #include <stdlib.h>
   5          #include <string.h>
   6          #include <absacc.h>
   7          
   8          #define     SYSTEM_CLOCK                24500000
   9          #define   BAUD_RATE               115200
  10          #define   RX_BUFFER_SIZE              256
  11          #define   TX_BUFFER_SIZE              256
  12          
  13          #define   TX_WAIT_LIMIT       100 * (SYSTEM_CLOCK / 1000000)    // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  14          #define   RX_WAIT_LIMIT       100 * (SYSTEM_CLOCK / 1000000)    // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  15          
  16          sfr16     RCAP2             = 0xCA;                     // Timer 2 capture/reload
  17          sfr16     TMR2              = 0xCC;                           // Timer 2
  18          sfr16     RCAP3             = 0xCA;                             // Timer 3 reload registers
  19          sfr16     TMR3              = 0xCC;                             // Timer 3 counter registers
  20          sfr16     RCAP4             = 0xCA;                             // Timer 3 reload registers
  21          sfr16   TMR4            = 0xCC;               // Timer 4
  22          sfr16     DAC0              = 0xD2;                       // DAC0 data
  23          sfr16     DAC1              = 0xD2;                       // DAC1 data
  24          sfr16     ADC0              = 0xBE;                       // ADC0 data
  25          sfr16   PCA0            = 0xF9;               // PCA register
  26          
  27          #define   INTERRUPT_Timer_0       1
  28          #define   INTERRUPT_Timer_1       3
  29          #define   INTERRUPT_UART_0      4
  30          #define   INTERRUPT_Timer_2       5
  31          #define   INTERRUPT_SMB       7
  32          #define   INTERRUPT_CPA       9
  33          #define   INTERRUPT_COMP0_FALLING   10
  34          #define   INTERRUPT_COMP0_RISING    11
  35          #define   INTERRUPT_COMP1_FALLING   12
  36          #define   INTERRUPT_COMP1_RISING    13
  37          #define   INTERRUPT_Timer_3       14
  38          #define   INTERRUPT_Timer_4       16
  39          #define   INTERRUPT_ADC_0       15
  40          #define   INTERRUPT_ADC_2       18
  41          #define   INTERRUPT_UART_1      20
  42          
  43          //-------------------------------------------------------------------------------------------------------
  44          // Global Declarations
  45          //-------------------------------------------------------------------------------------------------------
  46          unsigned char tsByte;
  47          
  48          bit splashEnd = 0;
  49          bit screenReset = 0;
  50          bit ackFromScreen = 0;
  51          bit tsCommandReceived = 0;
  52          bit tsCommandTransmitted = 0;
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 2   

  53          
  54          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  55          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  56          unsigned char userCommand[RX_BUFFER_SIZE];
  57          
  58          unsigned int tsRxIn;
  59          unsigned int tsRxOut;
  60          unsigned int tsTxIn;
  61          unsigned int tsTxOut;
  62          
  63          bit tsRxEmpty;
  64          bit tsTxEmpty;
  65          bit tsLastCharGone;
  66          
  67          void systemClockInit(void)
  68          {
  69   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
  70   1        int i = 0;
  71   1      
  72   1        SFRPAGE  = CONFIG_PAGE;
  73   1      
  74   1          OSCICN    = 0x83;
  75   1      
  76   1        SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
  77   1      }
  78          
  79          void portInit(void)
  80          {
  81   1        char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
  82   1      
  83   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
  84   1      
  85   1        XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4
  86   1          XBR1 = 0x01;
  87   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up
  88   1      
  89   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
  90   1                                              // TX0 = P0.0; RX0 = P0.1
  91   1        P0 = 0xFF;                                  // Initialize port P0 latch
  92   1        P1 = 0xFF;                                  // Initialize port P1 latch
  93   1        P2 = 0xFF;                                  // Initialize port P2 latch
  94   1        P3 = 0xFF;                                  // Initialize port P3 latch
  95   1        P4 = 0xFF;                                  // Initialize port P4 latch
  96   1        P5 = 0xFF;                                  // Initialize port P5 latch
  97   1        P6 = 0xFF;                                  // Initialize port P6 latch
  98   1        P7 = 0xFF;                                  // Initialize port P7 latch
  99   1      
 100   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 101   1      }
 102          
 103          void enableInterrupts(void)
 104          {
 105   1        IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 106   1      }
 107          
 108          void uart0Init(void)
 109          {
 110   1         char SFRPAGE_SAVE;
 111   1      
 112   1         SFRPAGE_SAVE = SFRPAGE;                                              // Preserve SFRPAGE
 113   1      
 114   1         SFRPAGE = TMR2_PAGE;
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 3   

 115   1         TMR2CN = 0x00;                                                       // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 116   1         TMR2CF = 0x08;                                                       // SYSCLK is time base; no output; up 
             -count only
 117   1         RCAP2L = 0xF3;                                                               // Low byte
 118   1         RCAP2H = 0xFF;                                                               // High byte
 119   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 120   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 121   1      
 122   1         SFRPAGE = UART0_PAGE;
 123   1         SCON0 = 0x50;                                                        // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 124   1         SSTA0 = 0x05;                                                        // Enable baud rate
 125   1                                                                              // Use timer 2 as RX and TX baud rate 
             -source
 126   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 127   1      
 128   1         SFRPAGE = SFRPAGE_SAVE;                                              // Restore SFRPAGE
 129   1      }
 130          
 131          void disableWatchdog(void)
 132          {
 133   1        WDTCN = 0xDE;                                               // Disable watchdog timer
 134   1          WDTCN = 0xAD;
 135   1      }
 136          
 137          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 138          {
 139   1          char SFRPAGE_SAVE = SFRPAGE;
 140   1        unsigned int i = 0;
 141   1        unsigned long txWaitCounter = 0;
 142   1      
 143   1        SFRPAGE = UART0_PAGE;
 144   1      
 145   1          if(RI0 == 1)                                                        // There is a char in SBUF
 146   1          {
 147   2            RI0 = 0;                                                    // Clear interrupt flag
 148   2      
 149   2            tsByte = SBUF0;                                             // Read a character from UART
 150   2      
 151   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 152   2              {
 153   3                if(tsByte != '\r')                          // Check end of a command from touch screen
 154   3            {
 155   4              tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 156   4              tsRxIn++;                           // Increment index
 157   4            }
 158   3                else                                // If it is CR character, it marks end of command
 159   3            {
 160   4              if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 161   4              {
 162   5                if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 163   5                {
 164   6                  splashEnd = 1;                                        // Detect end of splash screen
 165   6                  screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 166   6                }
 167   5                else
 168   5                {
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 4   

 169   6                  splashEnd = 0;                                          // End of splash screen NOT detected
 170   6                  screenReset = 0;
 171   6                }
 172   5              }
 173   4              else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 174   4              {                               // A command starts with '('
 175   5                for(i = 0; i < tsRxIn; i++)
 176   5                {
 177   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 178   6                }
 179   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 180   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 181   5              }
 182   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == 'p' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 183   4              {                               // A command starts with '('
 184   5                for(i = 0; i < tsRxIn; i++)
 185   5                {
 186   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 187   6                }
 188   5                userCommand[tsRxIn]='\0';
 189   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 190   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 191   5              }
 192   4              else                              // Not a command from touch screen controller
 193   4              {
 194   5                ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 195   5                tsCommandReceived = 0;                    // No need to set flag because it is not a command
 196   5              }
 197   4      
 198   4              for(i = 0; i < tsRxIn; i++)
 199   4              {
 200   5                tsRxBuffer[i] = '\0';                   // Delete all contents
 201   5              }
 202   4      
 203   4              tsRxOut = 0;                          // Reset index Out
 204   4              tsRxIn = 0;                           // Reset index In
 205   4            }
 206   3              }
 207   2          else                                  // Reset all indexes
 208   2          {
 209   3            while(tsRxOut < tsRxIn)
 210   3            {
 211   4              tsRxBuffer[tsRxOut] = '\0';
 212   4              tsRxOut++;
 213   4            }
 214   3            tsRxOut = 0;
 215   3            tsRxIn = 0;
 216   3            tsCommandReceived = 0;
 217   3          }
 218   2         }
 219   1      
 220   1         if(TI0 == 1)                                                 // Check if one character is successfully sent out
 221   1         {
 222   2              TI0 = 0;                                                    // Clear interrupt flag
 223   2      
 224   2          if(tsTxEmpty == 0)                            // TX buffer has something to send
 225   2          {
 226   3            SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 227   3            tsTxOut++;                              // Move to next character
 228   3      
 229   3            while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmission TI0 = 
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 5   

             -1
 230   3            if(txWaitCounter >= TX_WAIT_LIMIT)
 231   3            {
 232   4              TI0 = 1;                            // TI0 is not set by hardware, set it by software
 233   4            }                                 // When TI0 is set to 1, this ISR is executed again
 234   3      
 235   3            txWaitCounter = 0;                          // Reset counter for next execution
 236   3      
 237   3            if(tsTxOut >= TX_BUFFER_SIZE)
 238   3            {
 239   4              tsTxOut = 0;                          // Reset index to 0
 240   4            }
 241   3      
 242   3            if(tsTxOut == tsTxIn)                       // If two indexes are equal
 243   3            {
 244   4              tsTxEmpty = 1;                          // No more character in buffer. Empty
 245   4            }
 246   3          }
 247   2          else
 248   2          {
 249   3            tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 250   3          }
 251   2          }
 252   1      
 253   1        SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 254   1      }
 255          
 256          //-------------------------------------------------------------------------------------------------------
 257          // Function Name: sendCommand
 258          // Return Value: None
 259          // Parmeters: s (a string to send)
 260          // Function Description: This function sends a command from the touch screen
 261          //-------------------------------------------------------------------------------------------------------
 262          void sendCommand(const char * s)
 263          {
 264   1        char SFRPAGE_SAVE = SFRPAGE;
 265   1      
 266   1        while(*s != '\0')                             // Search for end of touch screen command in buffer
 267   1          {
 268   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 269   2          {
 270   3            tsTxBuffer[tsTxIn++] = *s;
 271   3            if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 272   3            {
 273   4              tsTxIn = 0;                           // Reset if limit reached
 274   4            }
 275   3      
 276   3            if(tsTxEmpty == 1)                          // If buffer is empty
 277   3            {
 278   4              tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 279   4            }
 280   3          }
 281   2      
 282   2          s++;                                  // Point to next char to send out
 283   2          }
 284   1      
 285   1        if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 286   1        {
 287   2          tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 288   2          SFRPAGE = UART0_PAGE;
 289   2          TI0 = 1;                                                            // Set this flage to call ISR to send 
             -out one character
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 6   

 290   2        }
 291   1      
 292   1        SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 293   1      }
 294          
 295          // Control variables
 296          unsigned int funcToRun = 0; // default 0
 297          
 298          // Control functions
 299          int get_function_code();
 300          int passcode[3]={0};
 301          void splash_page_load(); // function code == 11
 302          void login_page_load(); // function code == 21
 303          void login_attempts(); // function code == 22
 304          void login_clear_stars(); // function code == 23
 305          void login_disp_1_star(); // function code == 24
 306          void login_disp_2_star(); // function code == 25
 307          void login_disp_3_star(); // function code == 26
 308          void login_disp_4_star(); // function code == 27
 309          void locked_page_load(); // function code == 31
 310          void update_wait_time(); // function code == 32
 311          void login_clear_disp(); // function code == 33
 312          
 313          void main()
 314          {
 315   1        int i = 0;
 316   1          char str[64];
 317   1      
 318   1          disableWatchdog();
 319   1          systemClockInit();
 320   1        portInit();
 321   1        enableInterrupts();
 322   1        uart0Init();
 323   1      
 324   1          tsLastCharGone = 1;
 325   1          tsTxOut = tsTxIn = 0;
 326   1          tsTxEmpty = 1;
 327   1      
 328   1          // load default settings
 329   1          sprintf(str, "z\r");
 330   1          sendCommand(str);
 331   1          sprintf(str, "m load_bar_full\r");
 332   1          sendCommand(str);
 333   1        while(1)
 334   1        {
 335   2              if (tsCommandReceived) {
 336   3                  switch (get_function_code()) {
 337   4                      case 11: splash_page_load(); break;
 338   4                      case 21: login_page_load(); break;
 339   4                      case 22: login_attempts(); break;
 340   4                      case 23: login_clear_stars(); break;
 341   4                      case 24: login_disp_1_star(); break;
 342   4                      case 25: login_disp_2_star(); break;
 343   4                      case 26: login_disp_3_star(); break;
 344   4                      case 27: login_disp_4_star(); break;
 345   4                  }
 346   3              }
 347   2        }
 348   1      }
 349          
 350          // Splash Page begin ==========
 351          
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 7   

 352          // function code == 11
 353          void splash_page_load() {
 354   1          funcToRun = 0;
 355   1      }
 356          // Splash page end ============
 357          
 358          int get_function_code() {
 359   1          // TODO, receive commands from screen
 360   1          if(passcode[0]==0)
 361   1          {
 362   2            passcode[0]=userCommand[3]-'0';
 363   2            tsCommandReceived=0;
 364   2            return 24;
 365   2          }
 366   1          else if(passcode[1]==0)
 367   1          {
 368   2            passcode[1]=userCommand[3]-'0';
 369   2            tsCommandReceived=0;
 370   2            return 25;
 371   2          }
 372   1          else if(passcode[2]==0)
 373   1          {
 374   2            passcode[2]=userCommand[3]-'0';
 375   2            tsCommandReceived=0;
 376   2            return 26;
 377   2          }
 378   1          else if(passcode[3]==0)
 379   1          {
 380   2            passcode[3]=userCommand[3]-'0';
 381   2            tsCommandReceived=0;
 382   2            return 27;
 383   2          }
 384   1          return 0;
 385   1      }
 386          
 387          // Login Page begin ===========
 388          
 389          // function code == 21
 390          void login_page_load() {
 391   1      
 392   1      }
 393          
 394          // function code == 22
 395          void login_attempts() {
 396   1      
 397   1      }
 398          
 399          // function code == 23
 400          void login_clear_stars() {
 401   1      
 402   1      }
 403          
 404          // function code == 24
 405          void login_disp_1_star() {
 406   1          char str[64];
 407   1          sprintf(str, "xi 15 184 127\r");
 408   1          sendCommand(str);
 409   1      }
 410          
 411          // function code == 25
 412          void login_disp_2_star() {
 413   1          char str[64];
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 8   

 414   1          sprintf(str, "xi 15 271 127\r");
 415   1          sendCommand(str);
 416   1      }
 417          
 418          // function code == 26
 419          void login_disp_3_star() {
 420   1          char str[64];
 421   1          sprintf(str, "xi 15 358 127\r");
 422   1          sendCommand(str);
 423   1      }
 424          
 425          // function code == 27
 426          void login_disp_4_star() {
 427   1          char str[64];
 428   1          sprintf(str, "xi 15 446 127\r");
 429   1          sendCommand(str);
 430   1          if(passcode[0]==1 && passcode[1]==2 && passcode[2]==3 && passcode[3]==4)
 431   1          {
 432   2            sprintf(str, "m main_page\r");
 433   2            sendCommand(str);
 434   2          }
 435   1          else
 436   1          {
 437   2            sprintf(str, "xi 40 0 0\r");
 438   2            sendCommand(str);
 439   2            sprintf(str, "w 2000\r");
 440   2            sendCommand(str);
 441   2            passcode[0]=0;
 442   2            passcode[1]=0;
 443   2            passcode[2]=0;
 444   2            passcode[3]=0;
 445   2            sprintf(str, "m display_login_page\r");
 446   2            sendCommand(str);
 447   2          }
 448   1      }
 449          // Login Page end =============
 450          
 451          // Locked out Page begin ======
 452          
 453          // function code == 31
 454          void locked_page_load() {
 455   1      
 456   1      }
 457          
 458          // function code == 32
 459          void update_wait_time() {
 460   1      
 461   1      }
 462          
 463          // function code == 33
 464          void login_clear_disp() {
 465   1      
 466   1      }
 467          // Locked out Page end ========


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1413    ----
   CONSTANT SIZE    =    134    ----
   XDATA SIZE       =    785     330
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.56.0.0   MAIN_1                                                            10/30/2017 00:22:44 PAGE 9   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
