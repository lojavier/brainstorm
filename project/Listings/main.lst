C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\mc_code\with_real_time_clock\main.c LARGE OPTIMIZE(8,SPEED) BROWSE DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          //-------------------------------------------------------------------------------------------------------
   4          // Global Declarations
   5          //-------------------------------------------------------------------------------------------------------
   6          int SETTINGS_DATE_X =163;
   7          int SETTINGS_DATE_Y =393;
   8          char SETTINGS_DATE_FG[7] = "00FF00";
   9          char SETTINGS_DATE_BG[7] = "000000";
  10          char SETTINGS_TIME_FG[7] = "00FF00";
  11          
  12          
  13          unsigned char tsByte;
  14          
  15          bit splashEnd = 0;
  16          bit screenReset = 0;
  17          bit ackFromScreen = 0;
  18          bit tsCommandReceived = 0;
  19          bit tsCommandTransmitted = 0;
  20          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  21          
  22          unsigned char sharedDataRx[SHARED_DATA_MAX];
  23          unsigned char sharedDataTx[SHARED_DATA_MAX];
  24          unsigned char eepromTx[EEPROM_TX_BUFFER];
  25          unsigned char eepromRx[EEPROM_RX_BUFFER];
  26          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  27          
  28          unsigned int pageCount;
  29          unsigned int bytesExtra;
  30          unsigned int eepromPageCounter;
  31          unsigned int startAddr;
  32          unsigned char slaveAddr;                                                // Target SMBus slave address
  33          unsigned char eepromDataByte;
  34          
  35          unsigned int numBytesRD;
  36          unsigned int numBytesWR;
  37          unsigned char slaveWriteDone;
  38          unsigned char slaveReadDone;
  39          unsigned char eepromWriteDone;
  40          unsigned char eepromReaddone;
  41          unsigned char rtcWriteDone;
  42          unsigned char rtcReadDone;
  43          
  44          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  45          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  46          unsigned char userCommand[RX_BUFFER_SIZE];
  47          
  48          unsigned int tsRxIn;
  49          unsigned int tsRxOut; 
  50          unsigned int tsTxIn;
  51          unsigned int tsTxOut;
  52          
  53          bit tsRxEmpty;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 2   

  54          bit tsTxEmpty;
  55          bit tsLastCharGone; 
  56          
  57          bit screenChanged;
  58          unsigned char screen;
  59          unsigned char lastScreen;
  60          
  61          const char code * Font[] = {/*0*/ "m10B", 
  62                        /*1*/ "m12B",
  63                        /*2*/ "m14B",
  64                        /*3*/ "m16B",
  65                        /*4*/ "m20B",
  66                        /*5*/ "m24B",
  67                        /*6*/ "m32B",
  68                        /*7*/ "m48",
  69                        /*8*/ "m64"};
  70          
  71          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  72          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  73          
  74          unsigned int startAddr;
  75          unsigned char slaveAddr;                                                // Target SMBus slave address
  76          
  77          unsigned int numBytesRD;
  78          unsigned int numBytesWR;
  79          
  80          unsigned char slaveWriteDone;
  81          unsigned char slaveReadDone;
  82                                      
  83          unsigned char roomTemp1;
  84          unsigned char roomTemp2;
  85          unsigned char roomTemp3;
  86                                      
  87          unsigned char seconds;
  88          unsigned char minutes;
  89          unsigned char hours;
  90          unsigned char hours24;
  91          unsigned char amPm;
  92          unsigned char day;
  93          unsigned char date;
  94          unsigned char month;
  95          unsigned char year;
  96          unsigned char century;
  97          unsigned char timeMode;
  98          unsigned char currentIndex = 0;
  99          unsigned char minuteIndex = 0;
 100          unsigned char hourIndex = 0;
 101          
 102          unsigned char currentDate;
 103          unsigned char currentMonth;
 104          unsigned char currentYear;
 105          
 106          unsigned char realTimeClockItems;
 107          
 108          unsigned char adjustedSeconds;
 109          unsigned char adjustedMinutes;
 110          unsigned char adjustedHours;
 111          unsigned char adjustedAmPm;
 112          unsigned char adjustedDay;
 113          unsigned char adjustedDate;
 114          unsigned char adjustedMonth;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 3   

 115          unsigned char adjustedYear;
 116          unsigned char adjustedCentury;
 117          unsigned char adjustedTimeMode;
 118          
 119          bit monthUpdated;
 120          bit dateUpdated;
 121          bit yearUpdated;
 122          bit hoursUpdated;
 123          bit minutesUpdated;
 124          bit secondsUpdated;
 125          bit amPmUpdated;
 126          bit timeUpdated;
 127          bit monthDateYearUpdated;
 128          
 129          const char code * dayOfWeek[] =   {
 130                             /*0*/  "SUN",
 131                             /*1*/  "MON", 
 132                             /*2*/  "TUE",
 133                             /*3*/  "WED", 
 134                             /*4*/  "THU",
 135                             /*5*/  "FRI", 
 136                             /*6*/  "SAT"}; 
 137          
 138          const char code * monthOfYear[] =   {/*0*/  "NON",
 139                             /*1*/  "JAN",
 140                             /*2*/  "FEB", 
 141                             /*3*/  "MAR",
 142                             /*4*/  "APR", 
 143                             /*5*/  "MAY",
 144                             /*6*/  "JUN", 
 145                             /*7*/  "JUL",
 146                             /*8*/  "AUG",
 147                             /*9*/  "SEP",
 148                             /*10*/ "OCT", 
 149                             /*11*/ "NOV",
 150                             /*12*/ "DEC"};
 151          
 152          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 153                            /*1*/ "WRITING DATA... WAIT!  ",
 154                            /*2*/ "DATA SUCCESSFULLY SAVED",
 155                            /*3*/ "ERROR                  "};
 156          
 157          //-------------------------------------------------------------------------------------------------------
 158          // System Configurations
 159          //-------------------------------------------------------------------------------------------------------
 160          void systemClockInit(void)
 161          {
 162   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 163   1        int i = 0;
 164   1          
 165   1        SFRPAGE  = CONFIG_PAGE;
 166   1        
 167   1          OSCICN    = 0x83;
 168   1      
 169   1        SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 170   1      }
 171          
 172          void portInit(void)
 173          {
 174   1        char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 175   1      
 176   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 4   

 177   1      
 178   1        XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                      
 179   1          XBR1 = 0x01;                    
 180   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up                       
 181   1          
 182   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 183   1                                              // TX0 = P0.0; RX0 = P0.1
 184   1        P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 185   1                                              // TX1 = P1.0; RX1 = P1.1
 186   1        P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pull
 187   1        
 188   1        P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 189   1                                              
 190   1        P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 191   1        
 192   1        P6MDOUT = 0x00;
 193   1                                                                                    
 194   1        P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 195   1        
 196   1        P0 = 0xFF;                                  // Initialize port P0 latch
 197   1        P1 = 0xFF;                                  // Initialize port P1 latch
 198   1        P2 = 0xFF;                                  // Initialize port P2 latch
 199   1        P3 = 0xFF;                                  // Initialize port P3 latch
 200   1        P4 = 0xFF;                                  // Initialize port P4 latch
 201   1        P5 = 0xFF;                                  // Initialize port P5 latch
 202   1        P6 = 0xFF;                                  // Initialize port P6 latch
 203   1        P7 = 0xFF;                                  // Initialize port P7 latch
 204   1      
 205   1        RHW = 0;                                  // Pull low SMB error line
 206   1      
 207   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 208   1      }
 209          
 210          void enableInterrupts(void)
 211          {
 212   1        IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 213   1        EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 214   1        EIE2 |= 0x40;                               // Enable UART1 interrupt
 215   1        EIE1 |= 0x0A;                               // Enable SMBus interrupt
 216   1      }
 217          
 218          void uart0Init(void)
 219          {
 220   1         char SFRPAGE_SAVE;
 221   1      
 222   1         SFRPAGE_SAVE = SFRPAGE;                                              // Preserve SFRPAGE
 223   1      
 224   1         SFRPAGE = TMR2_PAGE;
 225   1         TMR2CN = 0x00;                                                       // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 226   1         TMR2CF = 0x08;                                                       // SYSCLK is time base; no output; up 
             -count only
 227   1         RCAP2L = 0xF3;                                                               // Low byte
 228   1         RCAP2H = 0xFF;                                                               // High byte
 229   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 230   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 231   1      
 232   1         SFRPAGE = UART0_PAGE;
 233   1         SCON0 = 0x50;                                                        // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 5   

 234   1         SSTA0 = 0x05;                                                        // Enable baud rate                   
             -                                                
 235   1                                                                              // Use timer 2 as RX and TX baud rate 
             -source
 236   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 237   1      
 238   1         SFRPAGE = SFRPAGE_SAVE;                                              // Restore SFRPAGE
 239   1      }
 240          
 241          void disableWatchdog(void)
 242          {
 243   1        WDTCN = 0xDE;                                               // Disable watchdog timer
 244   1          WDTCN = 0xAD;
 245   1      }
 246          
 247          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 248          {
 249   1          char SFRPAGE_SAVE = SFRPAGE;
 250   1        unsigned int i = 0;
 251   1        unsigned long txWaitCounter = 0;
 252   1      
 253   1        SFRPAGE = UART0_PAGE;
 254   1      
 255   1          if(RI0 == 1)                                                        // There is a char in SBUF
 256   1          {
 257   2            RI0 = 0;                                                    // Clear interrupt flag
 258   2      
 259   2            tsByte = SBUF0;                                             // Read a character from UART
 260   2      
 261   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 262   2              {
 263   3                if(tsByte != '\r')                          // Check end of a command from touch screen
 264   3            {
 265   4              tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 266   4              tsRxIn++;                           // Increment index
 267   4            }
 268   3                else                                // If it is CR character, it marks end of command
 269   3            {                               
 270   4              if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 271   4              {
 272   5                if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 273   5                {
 274   6                  splashEnd = 1;                                        // Detect end of splash screen
 275   6                  screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 276   6                }
 277   5                else
 278   5                {
 279   6                  splashEnd = 0;                                          // End of splash screen NOT detected
 280   6                  screenReset = 0;                  
 281   6                }
 282   5              }
 283   4              else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 284   4              {                               // A command starts with '('
 285   5                for(i = 0; i < tsRxIn; i++)
 286   5                {
 287   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 288   6                }
 289   5      
 290   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 291   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 6   

 292   5              }
 293   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == 'o' && tsRxBuffer[2] == 'a')                   // It is a comm
             -and from touch screen controller
 294   4              {                               // A command starts with '('
 295   5                for(i = 0; i < tsRxIn; i++)
 296   5                {
 297   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 298   6                }
 299   5                userCommand[tsRxIn]='\0';
 300   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 301   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 302   5              }
 303   4              else if(tsRxBuffer[0] == 's' && tsRxBuffer[1] == 't' && tsRxBuffer[2] == 'a')                   // It is a comm
             -and from touch screen controller
 304   4              {                               // A command starts with '('
 305   5                for(i = 0; i < tsRxIn; i++)
 306   5                {
 307   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 308   6                }
 309   5                userCommand[tsRxIn]='\0';
 310   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 311   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 312   5              }
 313   4              else if(tsRxBuffer[0] == 'g' && tsRxBuffer[1] == 'e' && tsRxBuffer[2] == 't')                   // It is a comm
             -and from touch screen controller
 314   4              {                               // A command starts with '('
 315   5                for(i = 0; i < tsRxIn; i++)
 316   5                {
 317   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 318   6                }
 319   5                userCommand[tsRxIn]='\0';
 320   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 321   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 322   5              }
 323   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == '2' && tsRxBuffer[2] == '4')                   // It is a comm
             -and from touch screen controller
 324   4              {                               // A command starts with '('
 325   5                for(i = 0; i < tsRxIn; i++)
 326   5                {
 327   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 328   6                }
 329   5                userCommand[tsRxIn]='\0';
 330   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 331   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 332   5              }
 333   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == 'p' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 334   4              {                               // A command starts with '('
 335   5                for(i = 0; i < tsRxIn; i++)
 336   5                {
 337   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 338   6                }
 339   5                userCommand[tsRxIn]='\0';
 340   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 341   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 342   5              }
 343   4              else if(tsRxBuffer[0] == 'e' && tsRxBuffer[1] == 'n' && tsRxBuffer[2] == 'd')                   // It is a comm
             -and from touch screen controller
 344   4              {                               // A command starts with '('
 345   5                for(i = 0; i < tsRxIn; i++)
 346   5                {
 347   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 7   

 348   6                }
 349   5                userCommand[tsRxIn]='\0';
 350   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 351   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 352   5              }
 353   4              else if(tsRxBuffer[0] == 'm' && tsRxBuffer[1] == 'p' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 354   4              {                               // A command starts with '('
 355   5                for(i = 0; i < tsRxIn; i++)
 356   5                {
 357   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 358   6                }
 359   5                userCommand[tsRxIn]='\0';
 360   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 361   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 362   5              }
 363   4              else if(tsRxBuffer[0] == 'n' && tsRxBuffer[1] == 's' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 364   4              {                               // A command starts with '('
 365   5                for(i = 0; i < tsRxIn; i++)
 366   5                {
 367   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 368   6                }
 369   5                userCommand[tsRxIn]='\0';
 370   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 371   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 372   5              }
 373   4              else if(tsRxBuffer[0] == 'd' && tsRxBuffer[1] == 't' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 374   4              {                               // A command starts with '('
 375   5                for(i = 0; i < tsRxIn; i++)
 376   5                {
 377   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 378   6                }
 379   5                userCommand[tsRxIn]='\0';
 380   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 381   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 382   5              }
 383   4              else                              // Not a command from touch screen controller
 384   4              {
 385   5                ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 386   5                tsCommandReceived = 0;                    // No need to set flag because it is not a command
 387   5              }
 388   4      
 389   4              for(i = 0; i < tsRxIn; i++)
 390   4              {
 391   5                tsRxBuffer[i] = '\0';                   // Delete all contents
 392   5              }
 393   4              
 394   4              tsRxOut = 0;                          // Reset index Out
 395   4              tsRxIn = 0;                           // Reset index In
 396   4            } 
 397   3              }
 398   2          else                                  // Reset all indexes
 399   2          { 
 400   3            while(tsRxOut < tsRxIn)
 401   3            {
 402   4              tsRxBuffer[tsRxOut] = '\0';
 403   4              tsRxOut++;
 404   4            }
 405   3            tsRxOut = 0;
 406   3            tsRxIn = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 8   

 407   3            tsCommandReceived = 0;
 408   3          }
 409   2         }
 410   1      
 411   1         if(TI0 == 1)                                                 // Check if one character is successfully sent out
 412   1         {
 413   2              TI0 = 0;                                                    // Clear interrupt flag
 414   2      
 415   2          if(tsTxEmpty == 0)                            // TX buffer has something to send
 416   2          {
 417   3            SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 418   3            tsTxOut++;                              // Move to next character
 419   3      
 420   3            while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmission TI0 = 
             -1
 421   3            if(txWaitCounter >= TX_WAIT_LIMIT)
 422   3            {
 423   4              TI0 = 1;                            // TI0 is not set by hardware, set it by software
 424   4            }                                 // When TI0 is set to 1, this ISR is executed again
 425   3            
 426   3            txWaitCounter = 0;                          // Reset counter for next execution 
 427   3      
 428   3            if(tsTxOut >= TX_BUFFER_SIZE)
 429   3            {
 430   4              tsTxOut = 0;                          // Reset index to 0
 431   4            }               
 432   3      
 433   3            if(tsTxOut == tsTxIn)                       // If two indexes are equal
 434   3            {
 435   4              tsTxEmpty = 1;                          // No more character in buffer. Empty
 436   4            }
 437   3          }
 438   2          else
 439   2          {
 440   3            tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 441   3          }
 442   2          }
 443   1        
 444   1        SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 445   1      }
 446          //--------------------------------------------------------------------------------------------------------
             -------------------
 447          signed char bdata slaveFlags1;                            // Declare a set of 16 flags on slave
*** WARNING C231 IN LINE 447 OF ..\mc_code\with_real_time_clock\main.c: 'slaveFlags1': redefinition
 448          sbit waterPumpErr       =   slaveFlags1^0;                    // Starting byte address = 0x2E
 449          sbit airFlowSensorErr     = slaveFlags1^1;                    // bit address = 0x70
 450          sbit pressureSensorErr      = slaveFlags1^2;
 451          sbit roomTempSensorErr      = slaveFlags1^3;
 452          sbit waterInTempSensorErr   = slaveFlags1^4;
 453          sbit waterOutTempSensorErr    = slaveFlags1^5;
 454          sbit slaveRestarted       = slaveFlags1^6;
 455          sbit slaveWatchdogReset     = slaveFlags1^7;
 456          
 457          unsigned char bdata slaveFlags0;  
 458          sbit lowWaterPressure       =   slaveFlags0^0;
 459          sbit hiRoomTemp         = slaveFlags0^1;                    // If powerErr and this flag set, power is over 20%. Otherwi
             -se, power is under 20%
 460          sbit hiWaterInTemp        = slaveFlags0^2;                    // Set when power has error (hi or low). loHiPowerErr indi
             -cates hi or low
 461          sbit hiWaterOutTemp       = slaveFlags0^3;
 462          sbit hiLaserTemp          = slaveFlags0^4;
 463          sbit lowAirFlow         = slaveFlags0^5;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 9   

 464          sbit reserved6          = slaveFlags0^6;
 465          sbit reserved7          = slaveFlags0^7;
 466          
 467          
 468          void checkSlaveFlags(void)
 469          { 
 470   1        slaveFlags1 = readOneByteFromSlave(SLAVE_FLAGS_1);
 471   1        slaveFlags0 = readOneByteFromSlave(SLAVE_FLAGS_0);
 472   1      }
 473          
 474          
 475          //-------------------------------------------------------------------------------------------------------
 476          // Function Name: sendCommand
 477          // Return Value: None 
 478          // Parmeters: s (a string to send)
 479          // Function Description: This function sends a command from the touch screen
 480          //-------------------------------------------------------------------------------------------------------
 481          void sendCommand(const char * s)
 482          { 
 483   1        char SFRPAGE_SAVE = SFRPAGE;
 484   1        
 485   1        while(*s != '\0')                             // Search for end of touch screen command in buffer
 486   1          {
 487   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 488   2          {
 489   3            tsTxBuffer[tsTxIn++] = *s;
 490   3            if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 491   3            {
 492   4              tsTxIn = 0;                           // Reset if limit reached
 493   4            }
 494   3      
 495   3            if(tsTxEmpty == 1)                          // If buffer is empty
 496   3            {
 497   4              tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 498   4            }
 499   3          }
 500   2            
 501   2          s++;                                  // Point to next char to send out
 502   2          }
 503   1                                              
 504   1        if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 505   1        {
 506   2          tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 507   2          SFRPAGE = UART0_PAGE;                                     
 508   2          TI0 = 1;                                                            // Set this flage to call ISR to send 
             -out one character
 509   2        }                                     
 510   1                                              
 511   1        SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 512   1      }
 513          
 514          //-------------------------------------------------------------------------------------------------------
 515          // Function Name: displayText
 516          // Return Value: None 
 517          // Parmeters: fg, bg, size, message, x, y
 518          // Function Description: This function displays a text on the touch screen
 519          //-------------------------------------------------------------------------------------------------------
 520          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 521          {
 522   1        char str[TS_BUFFER_SIZE];                         // String
 523   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 10  

 524   1        sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 525   1        sendCommand(str);                           
 526   1        sprintf(str, "f %s\r", Font[size]);                     // Set text font
 527   1        sendCommand(str);                           
 528   1        sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
 529   1        sendCommand(str);                           
 530   1      }
 531          
 532          //-------------------------------------------------------------------------------------------------------
 533          // Function Name: showBitmap
 534          // Return Value: None 
 535          // Parmeters: index, x, y (bitmap index and coordinates)
 536          // Function Description: This function displays a bitmap image
 537          //-------------------------------------------------------------------------------------------------------
 538          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 539          {
 540   1        char str[TS_BUFFER_SIZE];
 541   1      
 542   1        sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 543   1        sendCommand(str);
 544   1      }
 545          
 546          //-------------------------------------------------------------------------------------------------------
 547          // Function Name: changeScreen
 548          // Return Value: None 
 549          // Parmeters: screenIndex (macro number)
 550          // Function Description: This function switches to the new screen
 551          //-------------------------------------------------------------------------------------------------------
 552          void changeScreen(const unsigned char screenIndex)
 553          {
 554   1        callMacro(screenIndex);                           // Change screen    
 555   1      }
 556          
 557          //-------------------------------------------------------------------------------------------------------
 558          // Function Name: callMacro
 559          // Return Value: None 
 560          // Parmeters: macroNumber (macro number in the macro file)
 561          // Function Description: This function calls a macro
 562          //-------------------------------------------------------------------------------------------------------
 563          void callMacro(const unsigned int macroNumber)
 564          {
 565   1        char str[TS_BUFFER_SIZE];
 566   1      
 567   1        sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 568   1        sendCommand(str);
 569   1      }
 570          
 571          //-------------------------------------------------------------------------------------------------------
 572          // Function Name: scanUserInput
 573          // Return Value: None 
 574          // Parmeters: None
 575          // Function Description: This function processes commands from the touch screen
 576          //-------------------------------------------------------------------------------------------------------
 577          void scanUserInput(void)
 578          { 
 579   1        int i = 0;
 580   1      
 581   1        if(screen == MAIN_PAGE)                           // Main screen
 582   1        {    
 583   2          if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 584   2          {
 585   3            switch (userCommand[1])                         // Scan a command type
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 11  

 586   3            {
 587   4              case '1':                           // Main page
 588   4                changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 589   4                break;
 590   4              case '2':                           // Settings page
 591   4                changeScreen(SETTINGS_PAGE);
 592   4                break;
 593   4              case '3':                             // Service page
 594   4                changeScreen(SERVICE_PAGE);
 595   4                break;
 596   4              case 'A':
 597   4                // Call a function here or do something here      
 598   4                break;
 599   4              case 'B':
 600   4                // Call a function here or do something here
 601   4                break;
 602   4              case 'C':
 603   4                // Call a function here or do something here
 604   4                break;  
 605   4              default:                            // Other options
 606   4                break;
 607   4              }
 608   3          }
 609   2          else                                  // Not a command, empty buffer with null char
 610   2          {
 611   3            i = 0;
 612   3            while(userCommand[i] != '\0')
 613   3            {
 614   4              userCommand[i] = '\0';
 615   4              i++;
 616   4            }
 617   3          } 
 618   2        }
 619   1        else if(screen == SETTINGS_PAGE)                      // Settings page
 620   1        {
 621   2          if(userCommand[0] == '(')
 622   2          {
 623   3            switch (userCommand[1])
 624   3            {
 625   4              case '1':
 626   4                changeScreen(MAIN_PAGE);
 627   4                break;
 628   4              case '2':
 629   4                changeScreen(SETTINGS_PAGE);
 630   4                break;
 631   4              case '3':
 632   4                changeScreen(SERVICE_PAGE);
 633   4                break;
 634   4              case 'A':
 635   4                // Call a function here or do something here
 636   4                break;
 637   4              case 'B':
 638   4                  // Call a function here or do something here
 639   4                break;
 640   4              case 'C':
 641   4                  // Call a function here or do something here
 642   4                break;
 643   4              default:
 644   4                break;
 645   4            }
 646   3          }
 647   2          else                                  // Not a command, empty buffer with null
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 12  

 648   2          {
 649   3            i = 0;
 650   3            while(userCommand[i] != '\0')
 651   3            {
 652   4              userCommand[i] = '\0';
 653   4              i++;
 654   4            }
 655   3          }       
 656   2        }
 657   1        else if(screen == SERVICE_PAGE)
 658   1        {
 659   2          if(userCommand[0] == '(')
 660   2          {
 661   3            switch (userCommand[1])
 662   3            {
 663   4              case '1':
 664   4                changeScreen(MAIN_PAGE);
 665   4                break;
 666   4              case '2':
 667   4                changeScreen(SETTINGS_PAGE);
 668   4                break;
 669   4              case '3':
 670   4                changeScreen(SERVICE_PAGE);
 671   4                break;
 672   4              case 'A':
 673   4                // Call a function here or do something here
 674   4              case 'B':
 675   4                // Call a function here or do something here
 676   4              case 'C':
 677   4                // Call a function here or do something here
 678   4              default:
 679   4                break;
 680   4            }
 681   3          }
 682   2          else                                  // Not a command, empty buffer with null
 683   2          {                               
 684   3            i = 0;
 685   3            while(userCommand[i] != '\0')
 686   3            {
 687   4              userCommand[i] = '\0';
 688   4              i++;
 689   4            }
 690   3          }       
 691   2        } 
 692   1        else
 693   1        {
 694   2      
 695   2        }
 696   1      
 697   1        i = 0;
 698   1        while(userCommand[i] != '\0')
 699   1        {
 700   2          userCommand[i] = '\0';                          // Delete all contents in array
 701   2          i++;
 702   2        }
 703   1      }
 704          
 705          //-------------------------------------------------------------------------------------------------------
 706          // Function Name: smbInit
 707          // Return Value: None 
 708          // Parmeters: None
 709          // Function Description: This function initializes the SMB bus 
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 13  

 710          //-------------------------------------------------------------------------------------------------------
 711          void smbInit(void)
 712          {
 713   1          int i;
 714   1        unsigned long pollingCounter = 0;
 715   1        char SFRPAGE_SAVE = SFRPAGE;
 716   1      
 717   1          SFRPAGE = SMB0_PAGE;
 718   1        while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because of e
             -rror or reset
 719   1          {
 720   2              SCL = 0;                                                          // Drive the clock low
 721   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 722   2              SCL = 1;                                                          // Release the clock
 723   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
 724   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
 725   2          }
 726   1            
 727   1        SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 728   1                                                                              // Enable SMBus Free timeout detect;
 729   1        SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and Thi
             -gh equations
 730   1                                        
 731   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 732   1      
 733   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 734   1        
 735   1        SMB_BUSY = 0;
 736   1                                                                                          // Release SMB
 737   1          slaveWriteDone = FALSE;
 738   1        slaveReadDone = FALSE;
 739   1        eepromWriteDone = FALSE;
 740   1        eepromReadDone = FALSE;
 741   1        rtcWriteDone = FALSE;
 742   1        rtcReadDone = FALSE;
 743   1      }
 744          
 745          //-------------------------------------------------------------------------------------------------------
 746          // Function Name: timer3Init
 747          // Return Value: None 
 748          // Parmeters: None
 749          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 750          //-------------------------------------------------------------------------------------------------------
 751          void timer3Init (void)
 752          {
 753   1          char SFRPAGE_SAVE = SFRPAGE;        
 754   1      
 755   1          SFRPAGE = TMR3_PAGE;
 756   1      
 757   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 758   1                                                // Timer 3 auto reload
 759   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 760   1      
 761   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 762   1          TMR3 = RCAP3;                                                     
 763   1      
 764   1          TR3 = 1;                                                            // Start Timer 3
 765   1      
 766   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 767   1      }
 768          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 14  

 769          //-------------------------------------------------------------------------------------------------------
 770          // Function Name: timer3ISR
 771          // Return Value: None 
 772          // Parmeters: None
 773          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 774          //-------------------------------------------------------------------------------------------------------
 775          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 776          {
 777   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 778   1      
 779   1          SFRPAGE = SMB0_PAGE;
 780   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 781   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 782   1      
 783   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
 784   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 785   1          SMB_BUSY = 0;                                                       // Free bus
 786   1         
 787   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 788   1      }
 789          
 790          //-------------------------------------------------------------------------------------------------------
 791          // Function Name: writeOneByteToSlave
 792          // Return Value: None 
 793          // Parmeters: target, startAddr, content
 794          // Function Description: This function writes one to the slave microprocessor
 795          //-------------------------------------------------------------------------------------------------------
 796          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 797          {       
 798   1        sharedDataTx[startAddr] = content;
 799   1        smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 800   1      }
 801          
 802          //-------------------------------------------------------------------------------------------------------
 803          // Function Name: readOneByteFromSlave
 804          // Return Value: long 
 805          // Parmeters: startAddr, bytes
 806          // Function Description: This function reads one from the slave microprocessor
 807          //-------------------------------------------------------------------------------------------------------
 808          unsigned char readOneByteFromSlave(unsigned char startAddr)
 809          {
 810   1        smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 811   1        return sharedDataRx[startAddr];                                               
 812   1      }
 813          
 814          //-------------------------------------------------------------------------------------------------------
 815          // Function Name: writeBytesToRealTimeClock
 816          // Return Value: None 
 817          // Parmeters: target, startAddr, bytes
 818          // Function Description: This function writes data byte to the real time clock DS3232
 819          //-------------------------------------------------------------------------------------------------------
 820          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 821          {
 822   1        smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 823   1      }
 824          
 825          //-------------------------------------------------------------------------------------------------------
 826          // Function Name: readBytesFromRealTimeClock
 827          // Return Value: None 
 828          // Parmeters: target, startAddr, bytes
 829          // Function Description: This function reads data byte from the real time clock DS3232
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 15  

 830          //-------------------------------------------------------------------------------------------------------
 831          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 832          {
 833   1        smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 834   1      }
 835          
 836          //-------------------------------------------------------------------------------------------------------
 837          // Function Name: smbRead
 838          // Return Value: unsigned char * 
 839          // Parmeters: target, startAddr, bytes
 840          // Function Description: This function reads from SM bus
 841          //-------------------------------------------------------------------------------------------------------
 842          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 843          {
 844   1        char SFRPAGE_SAVE = SFRPAGE;
 845   1      
 846   1        SFRPAGE = SMB0_PAGE;
 847   1        
 848   1        while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 849   1      
 850   1        SFRPAGE = SFRPAGE_SAVE;
 851   1          
 852   1          switch(deviceId)
 853   1          {
 854   2              case MCU_SLAVE_ADDR:
 855   2              case REAL_TIME_CLOCK_ADDR:
 856   2              case EEPROM_ADDR:
 857   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 858   2                  break;
 859   2              default:
 860   2                  break;  
 861   2          }
 862   1      
 863   1          SFRPAGE = SMB0_PAGE;
 864   1          
 865   1          while(BUSY || SMB_BUSY);
 866   1          slaveAddr = deviceId;                                                     // Address of MCU slave
 867   1          startAddr = location;                                 // Starting address to read from slave
 868   1          numBytesRD = bytes;                                   // Number of bytes to read
 869   1          
 870   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
 871   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
 872   1          STA = 1;
 873   1      
 874   1        while(BUSY || SMB_BUSY);                                                    // Wait for SMB
 875   1          
 876   1        SFRPAGE = SFRPAGE_SAVE;
 877   1            
 878   1          switch(deviceId)
 879   1          {
 880   2              case MCU_SLAVE_ADDR:
 881   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
 882   2                  break;
 883   2              case REAL_TIME_CLOCK_ADDR:
 884   2            while(rtcReadDone == 0);                                            // Wait until real time clock write c
             -ompleted or timeout occurs
 885   2            break;
 886   2              case EEPROM_ADDR:
 887   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
 888   2                  break;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 16  

 889   2              default:
 890   2                  break;  
 891   2          }  
 892   1      }
 893          
 894          //-------------------------------------------------------------------------------------------------------
 895          // Function Name: smbWrite
 896          // Return Value: unsigned char * 
 897          // Parmeters: target, startAddr, bytes
 898          // Function Description: This function reads to SM bus
 899          //-------------------------------------------------------------------------------------------------------
 900          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 901          {
 902   1        unsigned char i = 0;
 903   1        unsigned int pageWrittenDelay = 0;
 904   1        char SFRPAGE_SAVE = SFRPAGE;
 905   1          
 906   1        SFRPAGE = SMB0_PAGE;
 907   1        
 908   1        while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
 909   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
 910   1          startAddr = location;                               // Starting address to write to slave
 911   1      
 912   1          switch(deviceId)
 913   1          {
 914   2              case MCU_SLAVE_ADDR:                              // Pass through
 915   2              case DEVICE_DUMP_ADDR:                              // Pass through
 916   2                  numBytesWR = bytes;                             // Number of bytes to read
 917   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 918   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 919   2                  STA = 1;                                                          // Start transfer
 920   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 921   2                  break;
 922   2              case REAL_TIME_CLOCK_ADDR:
 923   2                  numBytesWR = bytes;                             // Number of bytes to read
 924   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 925   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 926   2                  STA = 1;                                                          // Start transfer
 927   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
 928   2                  break;
 929   2              default:
 930   2                  break;    
 931   2        }
 932   1      
 933   1        SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
 934   1      }
 935          
 936          //-------------------------------------------------------------------------------------------------------
 937          // Function Name: smbISR
 938          // Return Value: None 
 939          // Parmeters: None
 940          // Function Description: 
 941          // SMBus Interrupt Service Routine (ISR)
 942          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 943          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 944          //-------------------------------------------------------------------------------------------------------
 945          void smbISR (void) interrupt INTERRUPT_SMB using 2
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 17  

 946          {
 947   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
 948   1          static unsigned int TxCounter;                          // Initialize counter
 949   1          static unsigned int RxCounter;                          // Initialize counter
 950   1        static unsigned int slaveCount = 0;
 951   1        static unsigned int realTimeClockCount = 0;
 952   1        static unsigned int eepromCount = 0;
 953   1        static unsigned char eepromAddrDone;
 954   1        
 955   1        switch (SMB0STA >> 3)                             // Check SMB bus status
 956   1          {
 957   2      //-------------------------------------------------------------------------------------------------------
 958   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
 959   2      //-------------------------------------------------------------------------------------------------------
 960   2              case SMB_START:                               // Master initiates a transfer
 961   2      
 962   2      //-------------------------------------------------------------------------------------------------------
 963   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 964   2      //-------------------------------------------------------------------------------------------------------
 965   2              case SMB_REPEAT_START:
 966   2            SMB0DAT = slaveAddr;                                            // Load address of the slave.
 967   2                SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for the
             - R/W bit
 968   2                SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
 969   2            STA = 0;                                                      // Manually clear STA bit
 970   2      
 971   2                RxCounter = 0;                                                // Reset the counter
 972   2                TxCounter = 0;                                                // Reset the counter
 973   2            eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address  
 974   2                
 975   2            break;
 976   2      
 977   2      //-------------------------------------------------------------------------------------------------------
 978   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 979   2      // For a WRITE: Send the first data byte to the slave
 980   2      //-------------------------------------------------------------------------------------------------------
 981   2              case SMB_ADDR_W_TX_ACK_RX:
 982   2            if(slaveAddr == MCU_SLAVE_ADDR)
 983   2            {
 984   3              if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence only
 985   3              {
 986   4                STO = 1;                            // Stop this transfer
 987   4                SMB_BUSY = 0;                         // Releas SMB
 988   4              }
 989   3              else
 990   3              {
 991   4                SMB0DAT = startAddr;                      // Send 1 byte address to slave
 992   4                slaveWriteDone = 0;                       // Mark start of slave write
 993   4              }
 994   3            }
 995   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 996   2            {
 997   3              SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
 998   3              rtcWriteDone = 0;                         // Mark start of rtc write
 999   3            }
1000   2                  else{}
1001   2                break;
1002   2      
1003   2      //-------------------------------------------------------------------------------------------------------
1004   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 18  

1005   2      //-------------------------------------------------------------------------------------------------------
1006   2              case SMB_ADDR_W_TX_NACK_RX:
1007   2            if(slaveAddr == MCU_SLAVE_ADDR)
1008   2            {
1009   3              if(slaveCount < MAX_NACK_RETRY)
1010   3              {
1011   4                slaveCount++;                         // Increment number of attempts when NACK is received
1012   4                STA = 1;                            // Restart a new transfer
1013   4              }
1014   3              else
1015   3              {
1016   4                slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
1017   4                slaveWriteDone = 1;
1018   4                STO = 1;
1019   4                SMB_BUSY = 0;
1020   4                FAIL = 1;
1021   4              } 
1022   3            }
1023   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1024   2            {
1025   3              if(realTimeClockCount < MAX_NACK_RETRY)
1026   3              {
1027   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1028   4                STA = 1;                            // Restart a new transfer
1029   4              }
1030   3              else
1031   3              {
1032   4                realTimeClockCount = 0;
1033   4                rtcWriteDone = 1;
1034   4                STO = 1;
1035   4                SMB_BUSY = 0;
1036   4                FAIL = 1;
1037   4              } 
1038   3            }
1039   2            else if(slaveAddr == EEPROM_ADDR)
1040   2            {
1041   3              if(eepromCount < MAX_NACK_RETRY)
1042   3              {
1043   4                eepromCount++;                          // Increment number of attempts when NACK is received
1044   4                STA = 1;                            // Restart a new transfer
1045   4              }
1046   3              else
1047   3              {
1048   4                eepromCount = 0;
1049   4                eepromWriteDone = 1;
1050   4                STO = 1;
1051   4                SMB_BUSY = 0;
1052   4                FAIL = 1;
1053   4              } 
1054   3            }
1055   2            else
1056   2            {}
1057   2      
1058   2                break;
1059   2      
1060   2      //-------------------------------------------------------------------------------------------------------
1061   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
1062   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
1063   2      //-------------------------------------------------------------------------------------------------------
1064   2              case SMB_DATA_TX_ACK_RX:
1065   2                if(slaveAddr == MCU_SLAVE_ADDR)
1066   2            {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 19  

1067   3              if(TxCounter < numBytesWR)
1068   3                  {
1069   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1070   4                      TxCounter++;
1071   4                  }
1072   3                  else
1073   3                  {
1074   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1075   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1076   4                slaveWriteDone = 1;                       // Mark end of slave write
1077   4                  }
1078   3            }
1079   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1080   2            {
1081   3              if(TxCounter < numBytesWR)
1082   3                  {
1083   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1084   4                      TxCounter++;
1085   4                  }
1086   3                  else
1087   3                  {
1088   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1089   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1090   4                rtcWriteDone = 1;                       // Mark end of slave write
1091   4                  }
1092   3            }
1093   2                break;
1094   2      
1095   2      //-------------------------------------------------------------------------------------------------------
1096   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1097   2      //-------------------------------------------------------------------------------------------------------
1098   2              case SMB_DATA_TX_NACK_RX:
1099   2            if(slaveAddr == MCU_SLAVE_ADDR)
1100   2            {
1101   3              if(slaveCount < MAX_NACK_RETRY)
1102   3              {
1103   4                slaveCount++;                         // Increment number of attempts when NACK is received
1104   4                STA = 1;                            // Restart a new transfer
1105   4              }
1106   3              else
1107   3              {
1108   4                slaveCount = 0;
1109   4                STO = 1;
1110   4                SMB_BUSY = 0;
1111   4                FAIL = 1;
1112   4              } 
1113   3            }
1114   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1115   2            {
1116   3              if(realTimeClockCount < MAX_NACK_RETRY)
1117   3              {
1118   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1119   4                STA = 1;                            // Restart a new transfer
1120   4              }
1121   3              else
1122   3              {
1123   4                realTimeClockCount = 0;
1124   4                STO = 1;
1125   4                SMB_BUSY = 0;
1126   4                FAIL = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 20  

1127   4              } 
1128   3            }
1129   2            else if(slaveAddr == EEPROM_ADDR)
1130   2            {
1131   3              if(eepromCount < MAX_NACK_RETRY)
1132   3              {
1133   4                eepromCount++;                          // Increment number of attempts when NACK is received
1134   4                STA = 1;                            // Restart a new transfer
1135   4              }
1136   3              else
1137   3              {
1138   4                eepromCount = 0;
1139   4                STO = 1;
1140   4                SMB_BUSY = 0;
1141   4                FAIL = 1;
1142   4              } 
1143   3            }
1144   2            else
1145   2            {}
1146   2                break;
1147   2      
1148   2      //-------------------------------------------------------------------------------------------------------
1149   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1150   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1151   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1152   2      //-------------------------------------------------------------------------------------------------------
1153   2              case SMB_ADDR_R_TX_ACK_RX:
1154   2                if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1155   2                {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1156   3                    AA = 0;                                                   // Clear AA flag before data byte is rec
             -eived
1157   3                                                                              // send NACK signal to slave after byte 
             -is received
1158   3                }
1159   2                else
1160   2                {
1161   3                    AA = 1;                                                   // More than one byte in this transfer,
1162   3                                                                              // send ACK after byte is received
1163   3                }
1164   2                break;
1165   2      
1166   2      //-------------------------------------------------------------------------------------------------------
1167   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1168   2      //-------------------------------------------------------------------------------------------------------
1169   2              case SMB_ADDR_R_TX_NACK_RX:
1170   2            if(slaveAddr == MCU_SLAVE_ADDR)
1171   2            {
1172   3              if(slaveCount < MAX_NACK_RETRY)
1173   3              {
1174   4                slaveCount++;                         // Increment number of attempts when NACK is received
1175   4                STA = 1;                            // Restart transfer after receiving a NACK
1176   4              }
1177   3              else
1178   3              {
1179   4                slaveCount = 0;                         // Reset counter
1180   4                STO = 1;
1181   4                SMB_BUSY = 0;
1182   4                FAIL = 1;
1183   4              } 
1184   3            }
1185   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1186   2            {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 21  

1187   3              if(realTimeClockCount < MAX_NACK_RETRY)
1188   3              {
1189   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1190   4                STA = 1;                            // Restart a new transfer
1191   4              }
1192   3              else
1193   3              {
1194   4                realTimeClockCount = 0;
1195   4                STO = 1;
1196   4                SMB_BUSY = 0;
1197   4                FAIL = 1;
1198   4              } 
1199   3            }
1200   2            else if(slaveAddr == EEPROM_ADDR)
1201   2            {
1202   3              if(eepromCount < MAX_NACK_RETRY)
1203   3              {
1204   4                eepromCount++;                          // Increment number of attempts when NACK is received
1205   4                STA = 1;                            // Restart a new transfer
1206   4              }
1207   3              else
1208   3              {
1209   4                eepromCount = 0;
1210   4                STO = 1;
1211   4                SMB_BUSY = 0;
1212   4                FAIL = 1;
1213   4              } 
1214   3            }
1215   2            else
1216   2            {}
1217   2                break;
1218   2      
1219   2      //-------------------------------------------------------------------------------------------------------
1220   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1221   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
1222   2      //-------------------------------------------------------------------------------------------------------
1223   2              case SMB_DATA_RX_ACK_TX:
1224   2            
1225   2            if(slaveAddr == MCU_SLAVE_ADDR)
1226   2            {
1227   3              if (RxCounter < numBytesRD)
1228   3                  {
1229   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1230   4                      AA = 1;                                                 // Send ACK to indicate byte received
1231   4                      RxCounter++;                                            // Increment the byte counter
1232   4                slaveReadDone = 0;                        // Mark start of slave read
1233   4                  }
1234   3                  else
1235   3                  {
1236   4                      AA = 0;                                                 // Send NACK to indicate last byte is re
             -ceived
1237   4                slaveReadDone = 1;                        // Mark end of slave read
1238   4                  }
1239   3            }
1240   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1241   2            {
1242   3              if(RxCounter < numBytesRD)
1243   3              {
1244   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1245   4                rtcReadDone = 0;
1246   4                
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 22  

1247   4                AA = 1;                             // Send ACK to indicate byte received
1248   4                RxCounter++;                          // Increment the byte counter
1249   4              }
1250   3              else
1251   3              {
1252   4                rtcReadDone = 1;
1253   4                AA = 0;                             // Send NACK to indicate last byte is received
1254   4              }
1255   3            }
1256   2            else if(slaveAddr == EEPROM_ADDR)
1257   2            {
1258   3              if(RxCounter < numBytesRD)
1259   3              {
1260   4                eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1261   4                AA = 1;                             // Send ACK to indicate byte received
1262   4                RxCounter++;                          // Increment the byte counter
1263   4                eepromReadDone = 0;                       // Mark start of fram read
1264   4              }
1265   3              else
1266   3              {
1267   4                AA = 0;                             // Send NACK to indicate last byte is received
1268   4                eepromReadDone = 1;                       // Mark end of fram read
1269   4              }
1270   3            }
1271   2                break;
1272   2      
1273   2      //-------------------------------------------------------------------------------------------------------
1274   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1275   2      // For a READ: Read operation has completed.  Read data register and send STOP
1276   2      //-------------------------------------------------------------------------------------------------------
1277   2              case SMB_DATA_RX_NACK_TX:
1278   2            if(slaveAddr == MCU_SLAVE_ADDR)
1279   2            {
1280   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1281   3                  STO = 1;                              // Stop transfer
1282   3                  SMB_BUSY = 0;                           // Release SMB
1283   3                  AA = 1;
1284   3              slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next transfer   
             -                                              
1285   3            }
1286   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1287   2            {
1288   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1289   3              rtcReadDone = 1;
1290   3      
1291   3              STO = 1;                              // Stop transfer
1292   3              SMB_BUSY = 0;                           // Release SMB
1293   3              AA = 1;                               // Send ACK to indicate byte received
1294   3            }
1295   2            else if(slaveAddr == EEPROM_ADDR)
1296   2            {
1297   3              eepromRx[RxCounter] = SMB0DAT;
1298   3              STO = 1;                              // Stop transfer
1299   3              SMB_BUSY = 0;                           // Release SMB
1300   3              AA = 1;
1301   3              eepromReadDone = 1;                         // Mark end of eeprom read      
1302   3            }
1303   2                break;
1304   2      
1305   2      //-------------------------------------------------------------------------------------------------------
1306   2      // Master Transmitter: Arbitration lost
1307   2      //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 23  

1308   2              case SMB_ARBITRATION_LOST:
1309   2                FAIL = 1;                                                     // Indicate failed transfer
1310   2                                                                              // and handle at end of ISR
1311   2                break;
1312   2      
1313   2      //-------------------------------------------------------------------------------------------------------
1314   2      // All other status codes invalid.  Reset communication
1315   2      //-------------------------------------------------------------------------------------------------------
1316   2              default:
1317   2                FAIL = 1;
1318   2                break;
1319   2         }
1320   1      //-------------------------------------------------------------------------------------------------------
1321   1      // If all failed, reset everything
1322   1      //-------------------------------------------------------------------------------------------------------
1323   1          if(FAIL)                                                            // If the transfer failed,
1324   1          {
1325   2              SMB0CN &= ~0x40;                                                  // Reset communication
1326   2              SMB0CN |= 0x40;
1327   2              STA = 0;
1328   2              STO = 0;
1329   2              AA = 0;
1330   2      
1331   2              SMB_BUSY = 0;                                                     // Free SMBus
1332   2      
1333   2              FAIL = 0;
1334   2                                                // Set to finish all pending processes
1335   2          slaveWriteDone = 1;                             // Mark end of slave write
1336   2          slaveReadDone = 1;                              // Mark end of slave read
1337   2              rtcWriteDone = 1;
1338   2          rtcReadDone = 1;
1339   2          eepromWriteDone = 1;                            // Mark end of eeprom write
1340   2          eepromReadDone = 1;                             // Mark end of eeprom read
1341   2        }
1342   1      
1343   1        SI = 0;                                                             // Clear interrupt flag
1344   1      }
1345          
1346          //-------------------------------------------------------------------------------------------------------
1347          // Function Name: setClockControl
1348          // Return Value: None 
1349          // Parmeters: None
1350          // Function Description: This function sets values to the real time clock control register
1351          // Check DS3232 documentation for more details of this this control register
1352          //-------------------------------------------------------------------------------------------------------
1353          void setClockControl(void)
1354          {
1355   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1356   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
1357   1        writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
1358   1      }
1359                            
1360          //-------------------------------------------------------------------------------------------------------
1361          // Function Name: setClock
1362          // Return Value: None 
1363          // Parmeters: None
1364          // Function Description: This function sets the new values to the real time clock
1365          //-------------------------------------------------------------------------------------------------------
1366          void setClock(void)
1367          { 
1368   1        unsigned char hoursAux;
1369   1        
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 24  

1370   1        sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to arr
             -ay before writing
1371   1        sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... are a
             -lready converted to BCD
1372   1        sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1373   1        sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1374   1        sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1375   1        sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1376   1        
1377   1        hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1378   1      
1379   1        hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1380   1        
1381   1        if(amPm == 'P')
1382   1        {
1383   2           hoursAux = hoursAux | 0x60;                          // Set AM/PM bit --> PM mode
1384   2        }
1385   1        else if(amPm == 'A')
1386   1        {
1387   2           hoursAux = hoursAux & 0x5F;                          // Clear AM/PM bit --> AM mode
1388   2        }
1389   1        
1390   1        sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1391   1        
1392   1        writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes to R
             -TC
1393   1      
1394   1        //resetAllDisplayCounters();                              // Update new values on screen
1395   1      }     
1396          
1397          //-------------------------------------------------------------------------------------------------------
1398          // Function Name: getClockData()
1399          // Return Value: None 
1400          // Parmeters: None
1401          // Function Description: This function gets the new values from the real time clock
1402          //-------------------------------------------------------------------------------------------------------
1403          void getClockData()
1404          {
1405   1        static unsigned char previousMonth = 0;
1406   1        static unsigned char previousDate = 0;
1407   1        static unsigned char previousYear = 0;
1408   1        static unsigned char previousHours = 0;
1409   1        static unsigned char previousMinutes = 0;
1410   1        static unsigned char previousSeconds = 0;
1411   1        
1412   1        unsigned int currentIndex = 0;
1413   1        unsigned char tempHours;
1414   1        
1415   1        readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1416   1      
1417   1        seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal for s
             -econds (1 byte)
1418   1        minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal for m
             -inutes (1 byte)
1419   1      
1420   1        tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/PM
1421   1      
1422   1        if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1423   1        {
1424   2          timeMode = TWELVE_HR_MODE;
1425   2      
1426   2          if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 25  

1427   2          {
1428   3            amPm = 'P';
1429   3          }
1430   2          else
1431   2          {
1432   3              amPm = 'A';
1433   3          }
1434   2        }
1435   1        else
1436   1        {
1437   2          timeMode = TWENTY_FOUR_HR_MODE;
1438   2        }
1439   1      
1440   1        hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore others)
1441   1      
1442   1        if(hours == 12)
1443   1        {
1444   2          if(amPm == 'A')
1445   2          {
1446   3            hours24 = 0;
1447   3          }
1448   2          else
1449   2          {
1450   3            hours24 = hours;
1451   3          } 
1452   2        }
1453   1        else
1454   1        {
1455   2          if(amPm == 'P')
1456   2          {
1457   3            hours24 = hours + 12;                           // Twenty four hour format if PM
1458   3          }
1459   2          else
1460   2          {
1461   3            hours24 = hours;                              // Twenty four hour format if AM
1462   3          }
1463   2        }
1464   1      
1465   1        day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day (1 
             -byte)
1466   1        date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for date (
             -1 byte)
1467   1        month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for mont
             -h (1 byte)
1468   1        year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for year (
             -1 byte)
1469   1      
1470   1        if(month != previousMonth || date != previousDate || year != previousYear)
1471   1        {
1472   2          monthDateYearUpdated = SET;   
1473   2        }
1474   1        if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1475   1        {
1476   2          timeUpdated = SET;
1477   2        }
1478   1      
1479   1        if(amPm == 'P')
1480   1        {
1481   2          currentIndex = ((12 + hours) * 60) + minutes;
1482   2        }
1483   1        else if(amPm == 'A')
1484   1        {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 26  

1485   2          if(hours == 12)
1486   2          {
1487   3            hours = 0;
1488   3          }
1489   2          
1490   2          currentIndex = (hours * 60) + minutes;
1491   2        }
1492   1        else
1493   1        {}
1494   1      
1495   1        minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1496   1        hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1497   1      
1498   1        previousDate = date;
1499   1        previousMonth = month;
1500   1        previousYear = year;
1501   1        previousHours = hours;
1502   1        previousMinutes = minutes;
1503   1        previousSeconds = seconds;
1504   1      }
1505          
1506          //-------------------------------------------------------------------------------------------------------
1507          // Function Name: moveDateTimeUp
1508          // Return Value: None 
1509          // Parmeters: None
1510          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1511          //-------------------------------------------------------------------------------------------------------
1512          void moveDateTimeUp(void)
1513          {
1514   1        char str[SPRINTF_SIZE];
1515   1        
1516   1        if(realTimeClockItems == MONTH_ADJUST)
1517   1        {
1518   2          adjustedMonth++;
1519   2          monthUpdated = SET;
1520   2      
1521   2          if(adjustedMonth > 12)
1522   2          {
1523   3            adjustedMonth = 1;                              // Roll over
1524   3          }
1525   2      
1526   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1527   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1528   2        }
1529   1        else if(realTimeClockItems == DATE_ADJUST)
1530   1        {
1531   2          adjustedDate++;
1532   2          dateUpdated = SET;
1533   2      
1534   2          if(adjustedDate > 31)
1535   2          {
1536   3            adjustedDate = 1;                             // Roll over
1537   3          }
1538   2      
1539   2          sprintf(str, "%bu   ", adjustedDate);
1540   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1541   2        }
1542   1        else if(realTimeClockItems == YEAR_ADJUST)
1543   1        {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 27  

1544   2          adjustedYear++;
1545   2          yearUpdated = SET;
1546   2      
1547   2          if(adjustedYear > 99)
1548   2          {
1549   3            adjustedYear = 99;
1550   3          }
1551   2      
1552   2          sprintf(str, "20%02bu", adjustedYear);
1553   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1554   2        }
1555   1        else if(realTimeClockItems == HOUR_ADJUST)
1556   1        {
1557   2          adjustedHours++;
1558   2          hoursUpdated = SET;
1559   2      
1560   2          if(adjustedHours > 12)
1561   2          {
1562   3            adjustedHours = 1;                              // Roll over
1563   3          }
1564   2      
1565   2          sprintf(str, "%bu   ", adjustedHours);
1566   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1567   2        }
1568   1        else if(realTimeClockItems == MINUTE_ADJUST)
1569   1        {
1570   2          adjustedMinutes++;
1571   2          minutesUpdated = SET;
1572   2      
1573   2          if(adjustedMinutes > 59)
1574   2          {
1575   3            adjustedMinutes = 0;
1576   3          }
1577   2      
1578   2          sprintf(str, "%bu   ", adjustedMinutes);
1579   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1580   2        }
1581   1        else if(realTimeClockItems == AMPM_ADJUST)
1582   1        {
1583   2          if(adjustedAmPm == 'P')
1584   2          {
1585   3            adjustedAmPm = 'A';
1586   3          }
1587   2          else if(adjustedAmPm == 'A')
1588   2          {
1589   3            adjustedAmPm = 'P';
1590   3          }
1591   2          else
1592   2          {}
1593   2      
1594   2          amPmUpdated = SET;
1595   2      
1596   2          sprintf(str, "%cM  ", adjustedAmPm);
1597   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1598   2        }
1599   1        else
1600   1        {}
1601   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 28  

1602          
1603          //-------------------------------------------------------------------------------------------------------
1604          // Function Name: moveDateTimeDown
1605          // Return Value: None 
1606          // Parmeters: None
1607          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1608          //-------------------------------------------------------------------------------------------------------
1609          void moveDateTimeDown(void)
1610          {
1611   1        char str[SPRINTF_SIZE];
1612   1      
1613   1        if(realTimeClockItems == MONTH_ADJUST)
1614   1        {
1615   2          adjustedMonth--;
1616   2            monthUpdated = SET;
1617   2      
1618   2          if(adjustedMonth < 1)
1619   2          {
1620   3            adjustedMonth = 12;                             // Roll over to hour 12
1621   3          }
1622   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1623   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1624   2        }
1625   1        else if(realTimeClockItems == DATE_ADJUST)
1626   1        {
1627   2          adjustedDate--;
1628   2          dateUpdated = SET;
1629   2      
1630   2          if(adjustedDate < 1)
1631   2          {
1632   3            adjustedDate = 31;                              // Roll over to day 31
1633   3          }
1634   2      
1635   2          sprintf(str, "%bu   ", adjustedDate);
1636   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1637   2        }
1638   1        else if(realTimeClockItems == YEAR_ADJUST)
1639   1        {
1640   2          if(adjustedYear > 0)
1641   2          {
1642   3            adjustedYear--;                               // Check if it is greater than 0 before decrementing                        
1643   3          }                                       // to avoid a negative number
1644   2          else
1645   2          {
1646   3            adjustedYear = 0;                             // Roll over to 99
1647   3          }
1648   2          
1649   2          yearUpdated = SET;
1650   2      
1651   2          sprintf(str, "20%02bu", adjustedYear);
1652   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1653   2        }
1654   1        else if(realTimeClockItems == HOUR_ADJUST)
1655   1        {
1656   2          if(adjustedHours > 0)
1657   2          {
1658   3            adjustedHours--;                              // Check if it is greater than 0 before decrementing
1659   3          }                                       // to avoid a negative number
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 29  

1660   2          else
1661   2          {
1662   3            adjustedHours = 12;
1663   3          }
1664   2      
1665   2          hoursUpdated = SET;
1666   2      
1667   2          sprintf(str, "%bu   ", adjustedHours);
1668   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1669   2        }
1670   1        else if(realTimeClockItems == MINUTE_ADJUST)
1671   1        {
1672   2          if(adjustedMinutes > 0)
1673   2          {
1674   3            adjustedMinutes--;                              // Check if it is greater than 0 before decrementing
1675   3          }                                       // to avoid a negative number
1676   2          else
1677   2          {
1678   3            adjustedMinutes = 59;
1679   3          }
1680   2      
1681   2          minutesUpdated = SET;
1682   2      
1683   2          sprintf(str, "%bu   ", adjustedMinutes);
1684   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1685   2        }
1686   1        else if(realTimeClockItems == AMPM_ADJUST)
1687   1        {
1688   2          if(adjustedAmPm == 'P')
1689   2          {
1690   3            adjustedAmPm = 'A';
1691   3          }
1692   2          else if(adjustedAmPm == 'A')
1693   2          {
1694   3            adjustedAmPm = 'P';
1695   3          }
1696   2          else
1697   2          {}
1698   2      
1699   2          amPmUpdated = SET;
1700   2      
1701   2          sprintf(str, "%cM  ", adjustedAmPm);
1702   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1703   2        }
1704   1        else
1705   1        {}
1706   1      }
1707          
1708          //-------------------------------------------------------------------------------------------------------
1709          // Function Name: enterDateTime
1710          // Return Value: None 
1711          // Parmeters: None
1712          // Function Description: This function confirms the date or time set by the user on the touch screen
1713          //-------------------------------------------------------------------------------------------------------
1714          void enterDateTime(void)
1715          {
1716   1        char str[SPRINTF_SIZE];
1717   1        
1718   1        realTimeClockItems++;                               // Move to next item
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 30  

1719   1        
1720   1        if(realTimeClockItems == MONTH_ADJUST)
1721   1        {
1722   2          monthUpdated = SET;
1723   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1724   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1725   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1726   2        }
1727   1        else if(realTimeClockItems == DATE_ADJUST)
1728   1        {
1729   2          dateUpdated = SET;
1730   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1731   2          sprintf(str, "%bu   ", adjustedDate);
1732   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1733   2        }
1734   1        else if(realTimeClockItems == YEAR_ADJUST)
1735   1        {
1736   2          yearUpdated = SET;
1737   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1738   2          sprintf(str, "20%02bu", adjustedYear);
1739   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1740   2        }
1741   1        else if(realTimeClockItems == HOUR_ADJUST)
1742   1        {
1743   2          hoursUpdated = SET;
1744   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1745   2          sprintf(str, "%bu   ", adjustedHours);
1746   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1747   2        }
1748   1        else if(realTimeClockItems == MINUTE_ADJUST)
1749   1        {
1750   2          minutesUpdated = SET;
1751   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1752   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1753   2          sprintf(str, "%bu   ", adjustedMinutes);
1754   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1755   2        }
1756   1        else if(realTimeClockItems == AMPM_ADJUST)
1757   1        {
1758   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1759   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1760   2          sprintf(str, "%cM  ", adjustedAmPm);
1761   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1762   2        }
1763   1        else if(realTimeClockItems == DONE_ADJUST)
1764   1        {
1765   2          amPmUpdated = SET;                                // Set it if user explicitly press enter button
1766   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1767   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPL
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 31  

             -AY_Y);
1768   2        }
1769   1        else if(realTimeClockItems == ROLL_OVER_ADJUST)
1770   1        {
1771   2          realTimeClockItems = MONTH_ADJUST;                        // Set it for next round of real time clock items
1772   2          monthUpdated = SET;
1773   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1774   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1775   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1776   2        }
1777   1        else
1778   1        {}
1779   1      }
1780          
1781          //-------------------------------------------------------------------------------------------------------
1782          // Function Name: setClockOnScreen
1783          // Return Value: None 
1784          // Parmeters: None
1785          // Function Description: This function sets the real time clock on the touch screen
1786          //-------------------------------------------------------------------------------------------------------
1787          void setClockOnScreen(void)
1788          {   
1789   1        unsigned char hoursAux;
1790   1        
1791   1        if(monthUpdated == SET)
1792   1        {
1793   2          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);    // Get updated month from us
             -er on screen
1794   2          writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);             // Set month only (1 byte)
1795   2          monthUpdated = CLEAR;                             //Clear flag after writing to real time clock                         
1796   2        }
1797   1        
1798   1        if(dateUpdated == SET)
1799   1        {
1800   2          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);    // Get updated date from user 
             -on screen
1801   2          writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);              // Set date only (1 byte)
1802   2          dateUpdated = CLEAR;
1803   2        }
1804   1      
1805   1        if(yearUpdated == SET)
1806   1        {
1807   2          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);    // Get updated year from user 
             -on screen
1808   2          writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);              // Set year only (1 byte)
1809   2          yearUpdated = CLEAR;
1810   2        }
1811   1      
1812   1        if(hoursUpdated == SET || amPmUpdated == SET)
1813   1        {
1814   2          hoursAux = convertDecimalToBCD(adjustedHours);                  // Get updated hours from user on screen
1815   2          
1816   2          if(amPmUpdated == SET)
1817   2          {
1818   3            amPm = adjustedAmPm;                            // Set updated amPm from user on screen
1819   3          
1820   3            hoursAux = hoursAux | 0x40;                         // Set 12/24 bit --> 12 hour mode
1821   3            
1822   3            if(adjustedAmPm == 'P')
1823   3            {                                 
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 32  

1824   4              hoursAux = hoursAux | 0x60;                       // Set AM/PM bit --> PM mode
1825   4            }
1826   3            else if(adjustedAmPm == 'A')
1827   3            {                                 
1828   4              hoursAux = hoursAux & 0x5F;                       // Clear AM/PM bit --> AM mode
1829   4            }
1830   3            else
1831   3            {}
1832   3      
1833   3            amPmUpdated = CLEAR;
1834   3          }
1835   2          
1836   2          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1837   2          writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);             // Set hours only (1 byte)
1838   2          hoursUpdated = CLEAR; 
1839   2        }
1840   1      
1841   1        if(minutesUpdated == SET)
1842   1        {
1843   2          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated minutes fr
             -om user on screen
1844   2          writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);             // Set minutes only (1 byte)
1845   2          minutesUpdated = CLEAR;
1846   2        }
1847   1      
1848   1        realTimeClockItems = MONTH_ADJUST;                          // Set starting item = Month for adjustment
1849   1      
1850   1        getClockData();                                     // Get current month, date, year set by user
1851   1      
1852   1        //clockSetupDisplayRepeat = 0;                            // Display clock updates on screen                                    // Syste
             -m goes back to main page          
1853   1      }
1854          
1855          //-------------------------------------------------------------------------------------------------------
1856          // Function Name: resetClock
1857          // Return Value: None 
1858          // Parmeters: None
1859          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1860          //-------------------------------------------------------------------------------------------------------
1861          void resetClock(void)
1862          {
1863   1        seconds = 0;
1864   1        minutes = 0;
1865   1        hours = 0;
1866   1        amPm = 'P';
1867   1        day = 1;
1868   1        date = 1;
1869   1        month = 1;
1870   1        year = 0;
1871   1        century = 0;
1872   1        timeMode = 1;
1873   1      
1874   1        setClock();                                             // Set real time clock
1875   1      }
1876          
1877          //-------------------------------------------------------------------------------------------------------
1878          // Function Name: convertDecimalToBCD
1879          // Return Value: bcd 
1880          // Parmeters: decimal
1881          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1882          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 33  

1883          unsigned char convertDecimalToBCD(unsigned char decimal)
1884          {
1885   1        unsigned char bcd;
1886   1      
1887   1        bcd = (decimal / 10) << 4;                              // Get upper 4 bits
1888   1        bcd = bcd | (decimal % 10);                             // Get a BCD
1889   1      
1890   1        return bcd;
1891   1      }
1892          
1893          //-------------------------------------------------------------------------------------------------------
1894          // Function Name: convertBCDToDecimal
1895          // Return Value: decimal value 
1896          // Parmeters: bcd
1897          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1898          //-------------------------------------------------------------------------------------------------------
1899          unsigned char convertBCDToDecimal(unsigned char bcd)
1900          {
1901   1        unsigned char decimal;
1902   1      
1903   1        decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
1904   1                                                  // 8 bit number
1905   1        return decimal;
1906   1      }
1907          
1908          //-------------------------------------------------------------------------------------------------------
1909          // Function Name: displayClock
1910          // Return Value: None 
1911          // Parmeters: None
1912          // Function Description: This function displays clock data on the touch screen
1913          // The clock format is MM/DD/YYYY hour/minute/second
1914          //-------------------------------------------------------------------------------------------------------
1915          void displayClock(void)
1916          {
1917   1        char str[SPRINTF_SIZE];
1918   1        
1919   1        //if(screen == MAIN_PAGE)
1920   1        //{
1921   1              getClockData();
1922   1      
1923   1              sprintf(str, "%s %02bu, 20%02bu %s", monthOfYear[month], date, year, dayOfWeek[day]);
1924   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
1925   1              monthDateYearUpdated = CLEAR;
1926   1              
1927   1              sprintf(str, "%2bu : %02bu : %02bu %cM ", hours, minutes, seconds, amPm);
1928   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
1929   1        //}
1930   1        /*else if(screen == CLOCK_SETUP_PAGE)
1931   1        {
1932   1          if(buttonPressed == CLEAR)
1933   1          {
1934   1            getClockData();
1935   1        
1936   1            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1937   1            displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y);
1938   1            monthDateYearUpdated = CLEAR;
1939   1      
1940   1            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1941   1            displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y);
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 34  

1942   1            timeUpdated = CLEAR;
1943   1          }
1944   1        }*/
1945   1      }
1946          
1947          //-------------------------------------------------------------------------------------------------------
1948          // Main
1949          //-------------------------------------------------------------------------------------------------------
1950          // Control functions
1951          void bar_load(); // function code == 11
1952          void login_page_load(); // function code == 21
1953          void login_attempts(); // function code == 22
1954          void login_clear_stars(); // function code == 23
1955          void login_disp_1_star(); // function code == 24
1956          void login_disp_2_star(); // function code == 25
1957          void login_disp_3_star(); // function code == 26
1958          void login_disp_4_star(); // function code == 27
1959          void locked_page_load(); // function code == 31
1960          void update_wait_time(); // function code == 32
1961          void login_clear_disp(); // function code == 33
1962          void main_page_load();  // function code == 40
1963          void temp_page_load();  // function code == 41
1964          void motor_page_load(); // function code == 42
1965          void laser_page_load(); // function code == 43
1966          void setting_page_load(); // function code == 44
1967          void c_to_f();  // function code == 50
1968          void f_to_c();  // function code == 51
1969          void add_point(); // function code == 52
1970          void game_start();  // function code == 53
1971          void brightness_setting();  // function code == 54
1972          void time_setting();  // function code == 55
1973          void set_clock(); // function code == 56
1974          void contrast_setting();  // function code == 57
1975          
1976          int get_function_code();
1977          int passcode[4]={-1};
1978          int is_locked_out=0;
1979          int attempts=5;
1980          int is_in_temp_page=0;
1981          int is_in_motor_page=0;
1982          int is_in_game=0;
1983          int is_in_laser_page=0;
1984          int is_in_main_page=0;
1985          int is_in_setting_page=0;
1986          int is_in_c=1;
1987          int _delay=0;
1988          char userID[64];
1989          int stones=20;
1990          int duration=2000;
1991          int point=0;
1992          int brightness=120;
*** WARNING C231 IN LINE 1992 OF ..\mc_code\with_real_time_clock\main.c: 'brightness': redefinition
1993          int c=20;
1994          int set_time=0;
1995          double dayweek;
1996          int select=0;
1997          int clock_value;
1998          int contrast=255;
1999          int xyz=0;
2000            
2001          void main()
2002          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 35  

2003   1          int i = 0;
2004   1          char str[SPRINTF_SIZE];
2005   1          int testCounter = 0;
2006   1        
2007   1          disableWatchdog();
2008   1          systemClockInit();
2009   1          portInit();
2010   1          enableInterrupts();
2011   1          uart0Init();
2012   1          smbInit();
2013   1          timer3Init(); 
2014   1        
2015   1          tsLastCharGone = 1;
2016   1          tsTxOut = tsTxIn = 0;
2017   1          tsTxEmpty = 1;
2018   1        
2019   1        
2020   1          day=0;
2021   1          contrast_setting();
2022   1        
2023   1        while(1)
2024   1        {
2025   2          //------------------clock display in main page------------------
2026   2              if(_delay%10000==0 && (is_in_main_page || is_in_temp_page))
2027   2              {
2028   3              getClockData();   
2029   3              sprintf(str, "%2bu:%02bu%cM", hours, minutes, amPm);
2030   3              displayText("000000", "F7F9F8", 2, str, 277, 0);
2031   3              sprintf(str, "20%02bu/%02bu/%02bu", year, month, date);
2032   3              displayText("000000", "F7F9F8", 2, str, 265, 20);
2033   3              monthDateYearUpdated = CLEAR;
2034   3              }
2035   2              else if(_delay%10000==0 && is_in_motor_page)
2036   2              {
2037   3              getClockData();   
2038   3              sprintf(str, "%2bu:%02bu%cM", hours, minutes, amPm);
2039   3              displayText("000000", "FFFFFF", 2, str, 190, -4);
2040   3              monthDateYearUpdated = CLEAR;
2041   3              }
2042   2          //------------------time display------------------
2043   2              if(is_in_setting_page && _delay%10000==0)
2044   2              {
2045   3                displayClock();                             // Display clock data on the screen
2046   3                switch(select)
2047   3                {
2048   4                  case 0: break;
2049   4                  case 1: sprintf(str, "xi 16 163 393\r"); sendCommand(str); break;
2050   4                  case 2: sprintf(str, "xi 16 237 393\r"); sendCommand(str); break;
2051   4                  case 3: sprintf(str, "xi 17 318 393\r"); sendCommand(str); break;
2052   4                  case 4: sprintf(str, "xi 16 163 437\r"); sendCommand(str); break;
2053   4                  case 5: sprintf(str, "xi 16 258 437\r"); sendCommand(str); break;
2054   4                  case 6: sprintf(str, "xi 16 362 437\r"); sendCommand(str); break;
2055   4                  case 7: break;
2056   4                  default: break;
2057   4                }
2058   3          //      sprintf(str, "%s", amPm);
2059   3          //      displayText("000000", "FFFFFF", 4, str, 123, 0);
2060   3          /*    if(!set_time)
2061   3              {
2062   3                
2063   3                seconds=0;
2064   3                minutes=23;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 36  

2065   3                hours=4;
2066   3                amPm='A';
2067   3                date=27;
2068   3                month=11;
2069   3                year=17;
2070   3                century=20;
2071   3                timeMode=1;
2072   3                if(month==1 || month==2)                day=(date+1+2*(month+12)+3*((month+12)+1)/5+(year-1)+(year-1)/4-(year
             --1)/100+(year-1)/400)%7;
2073   3                else                                    day=(date+1+2*month+3*(month+1)/5+year+year/4-year/100+year/400)%7;
2074   3                setClock();
2075   3                set_time=1;
2076   3              }*/
2077   3              }
2078   2          //-----------------game display-------------------
2079   2              if(is_in_motor_page && _delay%10000==0)
2080   2              {
2081   3                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2082   3                  c=roomTemp;
2083   3                  if(is_in_c)
2084   3                  {
2085   4                    sprintf(str, "bodyC:%d", c);
2086   4                    displayText("000000", "FFFFFF", 2, str, 365,-4);
2087   4                  }
2088   3                  else
2089   3                  {
2090   4                    sprintf(str, "bodyF:%d", c*9/5+32);
2091   4                    displayText("000000", "FFFFFF", 2, str, 365,-4);              
2092   4                  }
2093   3                  if(is_in_game)
2094   3                  {
2095   4                    if(point<10)
2096   4                    {
2097   5                      sprintf(str, "%d", point);
2098   5                      displayText("000000", "FF0000", 6, str, 305,20);
2099   5                    }
2100   4                    else
2101   4                    {
2102   5                      sprintf(str, "%d", point);
2103   5                      displayText("000000", "FF0000", 6, str, 290,20);
2104   5                    }
2105   4                  }
2106   3      
2107   3              }
2108   2              if(is_in_game && _delay%40000==0)
2109   2              { 
2110   3                  if(stones<=20 && stones>15) 
2111   3                  {
2112   4                    if(c<20)  duration=700;
2113   4                    else      duration=700+((c-20)*130);
2114   4                    sprintf(str, "STAGE 1");
2115   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2116   4                  }
2117   3                  else if(stones<=15 && stones>10)  
2118   3                  {
2119   4                    if(c<20)  duration=500;
2120   4                    else      duration=500+((c-20)*100);
2121   4                    sprintf(str, "STAGE 2");
2122   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2123   4                  }
2124   3                  else if(stones<=10 && stones>5) 
2125   3                  {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 37  

2126   4                    if(c<20)  duration=300;
2127   4                    else      duration=300+((c-20)*70);
2128   4                    sprintf(str, "STAGE 3");
2129   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2130   4                  }
2131   3                  else if(stones<=5 && stones>0)    
2132   3                  {
2133   4                    if(c<20)  duration=100;
2134   4                    else      duration=100+((c-20)*40);
2135   4                    sprintf(str, "STAGE 4");
2136   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2137   4                  }
2138   3                  if(stones<=0) 
2139   3                  {
2140   4                    is_in_game=0;
2141   4                    if(point<10)
2142   4                    {
2143   5                      getClockData();
2144   5                      sprintf(str, "m lose %2bu %02bu %cM\r",  hours, minutes, amPm);
2145   5                      sendCommand(str);
2146   5                    }
2147   4                    else
2148   4                    {
2149   5                      sprintf(str, "m win %s\r", userID);
2150   5                      sendCommand(str);
2151   5                    }
2152   4                  }
2153   3                  else
2154   3                  {
2155   4                    int number=(rand() % 10) +1;
2156   4                    switch (number)
2157   4                    {
2158   5                    case 1:
2159   5                    sprintf(str, "m stone_display 133 118 %d\r", duration);
2160   5                    sendCommand(str);
2161   5                    break;
2162   5                    case 2:
2163   5                    sprintf(str, "m stone_display 118 159 %d\r", duration);
2164   5                    sendCommand(str);
2165   5                    break;
2166   5                    case 3:
2167   5                    sprintf(str, "m stone_display 124 202 %d\r", duration);
2168   5                    sendCommand(str);
2169   5                    break;
2170   5                    case 4:
2171   5                    sprintf(str, "m stone_display 130 263 %d\r", duration);
2172   5                    sendCommand(str); 
2173   5                    break;
2174   5                    case 5:
2175   5                    sprintf(str, "m stone_display 150 300 %d\r", duration);
2176   5                    sendCommand(str);
2177   5                    break;
2178   5                    case 6:
2179   5                    sprintf(str, "m stone_display 474 120 %d\r", duration);
2180   5                    sendCommand(str);
2181   5                    break;
2182   5                    case 7:
2183   5                    sprintf(str, "m stone_display 487 159 %d\r", duration);
2184   5                    sendCommand(str);
2185   5                    break;
2186   5                    case 8:
2187   5                    sprintf(str, "m stone_display 483 204 %d\r", duration);
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 38  

2188   5                    sendCommand(str); 
2189   5                    break;
2190   5                    case 9:
2191   5                    sprintf(str, "m stone_display 480 266 %d\r", duration);
2192   5                    sendCommand(str);
2193   5                    break;
2194   5                    case 10:
2195   5                    sprintf(str, "m stone_display 452 306 %d\r", duration);
2196   5                    sendCommand(str); 
2197   5                    break;              
2198   5                    default:
2199   5                    break;
2200   5                    }
2201   4                    stones--;
2202   4                  }
2203   3              }
2204   2          //-----------------text animation display-------------------
2205   2              if(is_in_laser_page && _delay%2000==0)
2206   2              { 
2207   3                  sprintf(str, "m text_display\r");
2208   3                  sendCommand(str);
2209   3              }
2210   2          //-----------------temperature display-------------------
2211   2              if(is_in_temp_page && _delay%20000==0)
2212   2              { 
2213   3                checkSlaveFlags();
2214   3                /*
2215   3                sprintf(str, "flag:%c", slaveFlags1^3);
2216   3                displayText("000000", "FFFFFF", 2, str, 100,0);
2217   3                sprintf(str, "flag:%c", slaveFlags1^4);
2218   3                displayText("000000", "FFFFFF", 2, str, 100,20);
2219   3                */
2220   3                if(is_in_c) //C
2221   3                {
2222   4                  //Left
2223   4                  if(slaveFlags1=='v')
2224   4                  {
2225   5                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2226   5                  sprintf(str, " %-5bu", roomTemp);
2227   5                  displayText("000000", "8D8989", 6, str, 208, 160);
2228   5                  }
2229   4                  else
2230   4                  {
2231   5                  sprintf(str, "ERR", roomTemp);
2232   5                  displayText("000000", "8D8989", 6, str, 208, 160);  
2233   5                  }
2234   4                  //Right
2235   4                  if(slaveFlags1=='v')
2236   4                  {
2237   5                  //roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2238   5                  sprintf(str, " %-5bu", roomTemp);
2239   5                  displayText("000000", "8D8989", 6, str, 338, 160);
2240   5                  }
2241   4                  else
2242   4                  {
2243   5                  sprintf(str, "ERR", roomTemp);
2244   5                  displayText("000000", "8D8989", 6, str, 338, 160);  
2245   5                  }
2246   4                }
2247   3                else  //F
2248   3                {
2249   4                  //Left
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 39  

2250   4                  if(slaveFlags1=='v')
2251   4                  {
2252   5                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2253   5                  sprintf(str, " %-5bu", roomTemp*9/5+32);
2254   5                  displayText("000000", "8D8989", 6, str, 208, 160);
2255   5                  }
2256   4                  else
2257   4                  {
2258   5                  sprintf(str, "ERR", roomTemp);
2259   5                  displayText("000000", "8D8989", 6, str, 208, 160);  
2260   5                  }
2261   4                  //Right
2262   4                  if(slaveFlags1=='v')
2263   4                  {
2264   5                  //roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2265   5                  sprintf(str, " %-5bu", roomTemp*9/5+32);
2266   5                  displayText("000000", "8D8989", 6, str, 338, 160);
2267   5                  }
2268   4                  else
2269   4                  {
2270   5                  sprintf(str, "ERR", roomTemp);
2271   5                  displayText("000000", "8D8989", 6, str, 338, 160);  
2272   5                  }
2273   4                }
2274   3              }
2275   2          //----------------------------------------------------------
2276   2              if (tsCommandReceived) {
2277   3                  switch (get_function_code()) {
2278   4                      case 11: bar_load(); break;
2279   4                      case 21: login_page_load(); break;
2280   4                      case 22: login_attempts(); break;
2281   4                      case 23: login_clear_stars(); break;
2282   4                      case 24: login_disp_1_star(); break;
2283   4                      case 25: login_disp_2_star(); break;
2284   4                      case 26: login_disp_3_star(); break;
2285   4                      case 27: login_disp_4_star(); break;
2286   4                      case 40: main_page_load(); break;
2287   4                      case 41: temp_page_load(); break;
2288   4                      case 42: motor_page_load(); break;
2289   4                      case 43: laser_page_load(); break;
2290   4                      case 44: setting_page_load(); break;
2291   4                      case 50: c_to_f(); break;
2292   4                      case 51: f_to_c(); break;
2293   4                      case 52: add_point(); break;
2294   4                      case 53: game_start(); break;
2295   4                      case 54: brightness_setting(); break;
2296   4                      case 55: time_setting(); break;
2297   4                      case 56: set_clock(); break;
2298   4                      case 57: contrast_setting(); break;
2299   4                      default: break;
2300   4                  }
2301   3              }
2302   2              _delay++;
2303   2        }
2304   1      }
2305          
2306          // Splash Page begin ==========
2307          
2308          // function code == 11
2309          void bar_load() {
2310   1          char str[64];
2311   1          sprintf(str, "m load_bar_full 220 275 100 03\r");
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 40  

2312   1          sendCommand(str);
2313   1      }
2314          // Splash page end ============
2315          
2316          int get_function_code() {
2317   1          // TODO, receive commands from screen
2318   1          if(userCommand[0]=='l' && userCommand[1]=='o' && userCommand[2]=='a')
2319   1          {
2320   2            is_in_temp_page=0;
2321   2            is_in_motor_page=0;
2322   2            is_in_game=0;
2323   2            is_in_laser_page=0;
2324   2            is_in_setting_page=0;
2325   2            is_in_main_page=0;
2326   2            is_in_c=1;
2327   2            attempts==5;
*** WARNING C275 IN LINE 2327 OF ..\mc_code\with_real_time_clock\main.c: expression with possibly no effect
2328   2            is_locked_out=0;
2329   2            select=0;
2330   2            tsCommandReceived=0;
2331   2            return 11;
2332   2          }
2333   1          else if(userCommand[0]=='g' && userCommand[1]=='e' && userCommand[2]=='t' && userCommand[3]=='_')
2334   1          {
2335   2            tsCommandReceived=0;
2336   2            return 52;
2337   2          }
2338   1          else if(userCommand[0]=='s' && userCommand[1]=='t' && userCommand[2]=='a' && userCommand[3]=='r')
2339   1          {
2340   2            tsCommandReceived=0;
2341   2            return 53;
2342   2          }
2343   1          else if(userCommand[0]=='l' && userCommand[1]=='2' && userCommand[2]=='4' && userCommand[3]=='1')
2344   1          {
2345   2            if      (userCommand[6]=='\0')  brightness=userCommand[5]-'0';
2346   2            else if (userCommand[7]=='\0')  brightness=(userCommand[5]-'0')*10 + userCommand[6]-'0';
2347   2            else                            brightness=(userCommand[5]-'0')*100 +(userCommand[6]-'0')*10 + userCommand[7]-'0';
2348   2            tsCommandReceived=0;
2349   2            return 54;
2350   2          }
2351   1          else if(userCommand[0]=='l' && userCommand[1]=='2' && userCommand[2]=='4' && userCommand[3]=='3')
2352   1          {
2353   2            if      (userCommand[6]=='\0')  clock_value=userCommand[5]-'0';
2354   2            else                            clock_value=(userCommand[5]-'0')*10 + userCommand[6]-'0';
2355   2            tsCommandReceived=0;
2356   2            return 56;
2357   2          }
2358   1          else if(userCommand[0]=='l' && userCommand[1]=='2' && userCommand[2]=='4' && userCommand[3]=='2')
2359   1          {
2360   2            if      (userCommand[6]=='\0')  contrast=userCommand[5]-'0';
2361   2            else if (userCommand[7]=='\0')  contrast=(userCommand[5]-'0')*10 + userCommand[6]-'0';
2362   2            else                            contrast=(userCommand[5]-'0')*100 +(userCommand[6]-'0')*10 + userCommand[7]-'0';
2363   2            tsCommandReceived=0;
2364   2            return 57;
2365   2          }
2366   1          else if(userCommand[0]=='d' && userCommand[1]=='t' && userCommand[2]=='_')
2367   1          {
2368   2            switch (userCommand[3])
2369   2            {
2370   3                case 'M': select=1; break;
2371   3                case 'd': select=2; break;
2372   3                case 'y': select=3; break;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 41  

2373   3                case 'h': select=4; break;
2374   3                case 'm': select=5; break;
2375   3                case 's': select=6; break;
2376   3                case 'a': select=7; break;
2377   3                default: break;
2378   3            }
2379   2            tsCommandReceived=0;
2380   2            return 55;
2381   2          }
2382   1          else if(userCommand[0]=='e' && userCommand[1]=='n' && userCommand[2]=='d' && userCommand[3]=='l')
2383   1          {
2384   2            tsCommandReceived=0;
2385   2            return 21;
2386   2          }
2387   1          else if(userCommand[0]=='m' && userCommand[1]=='p' && userCommand[2]=='_' && userCommand[3]=='l' && user
             -Command[4]=='o')
2388   1          {
2389   2            tsCommandReceived=0;
2390   2            return 23;
2391   2          }
2392   1          else if(passcode[0]==-1)
2393   1          {
2394   2            passcode[0]=userCommand[3]-'0';
2395   2            tsCommandReceived=0;
2396   2            return 24;
2397   2          }
2398   1          else if(passcode[1]==-1)
2399   1          {
2400   2            passcode[1]=userCommand[3]-'0';
2401   2            tsCommandReceived=0;
2402   2            return 25;
2403   2          }
2404   1          else if(passcode[2]==-1)
2405   1          {
2406   2            passcode[2]=userCommand[3]-'0';
2407   2            tsCommandReceived=0;
2408   2            return 26;
2409   2          }
2410   1          else if(passcode[3]==-1)
2411   1          {
2412   2            passcode[3]=userCommand[3]-'0';
2413   2            tsCommandReceived=0;
2414   2            return 27;
2415   2          }
2416   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='m' && userC
             -ommand[4]=='a')
2417   1          {
2418   2            tsCommandReceived=0;
2419   2            return 40;
2420   2          }
2421   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='t')
2422   1          {
2423   2            tsCommandReceived=0;
2424   2            return 41;
2425   2          }
2426   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='m' && userC
             -ommand[4]=='o')
2427   1          {
2428   2            tsCommandReceived=0;
2429   2            return 42;
2430   2          }
2431   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='l' && userC
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 42  

             -ommand[4]=='a')
2432   1          {
2433   2            tsCommandReceived=0;
2434   2            return 43;
2435   2          }
2436   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='s' && userC
             -ommand[4]=='e')
2437   1          {
2438   2            tsCommandReceived=0;
2439   2            return 44;
2440   2          }
2441   1              else if(userCommand[0]=='n' && userCommand[1]=='s'&& userCommand[2]=='_' && userCommand[3]=='f')
2442   1          {
2443   2            tsCommandReceived=0;
2444   2            return 50;
2445   2          }
2446   1              else if(userCommand[0]=='n' && userCommand[1]=='s'&& userCommand[2]=='_' && userCommand[3]=='c')
2447   1          {
2448   2            tsCommandReceived=0;
2449   2            return 51;
2450   2          }
2451   1          return 0;
2452   1      }
2453          
2454          // Login Page begin ===========
2455          
2456          // function code == 21
2457          void login_page_load() {
2458   1            char str[64];
2459   1            sprintf(userID, "");
2460   1            passcode[0]=-1;
2461   1            passcode[1]=-1;
2462   1            passcode[2]=-1;
2463   1            passcode[3]=-1;
2464   1            is_locked_out=0;
2465   1            is_in_main_page=0;
2466   1            sprintf(str, "m display_login_page\r");
2467   1            sendCommand(str);
2468   1      }
2469          
2470          // function code == 22
2471          void login_attempts() {
2472   1      
2473   1      }
2474          
2475          // function code == 23
2476          void login_clear_stars() {
2477   1            char str[64];
2478   1            attempts=5;
2479   1            sprintf(userID, "");
2480   1            passcode[0]=-1;
2481   1            passcode[1]=-1;
2482   1            passcode[2]=-1;
2483   1            passcode[3]=-1;
2484   1            is_locked_out=0;
2485   1            is_in_main_page=0;
2486   1            sprintf(str, "m display_login_page\r");
2487   1            sendCommand(str);
2488   1      }
2489          
2490          // function code == 24
2491          void login_disp_1_star() {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 43  

2492   1          char str[64];
2493   1          sprintf(str, "m display_asterik_1\r");
2494   1          sendCommand(str);
2495   1      }
2496          
2497          // function code == 25
2498          void login_disp_2_star() {
2499   1          char str[64];
2500   1          sprintf(str, "m display_asterik_2\r");
2501   1          sendCommand(str);
2502   1      }
2503          
2504          // function code == 26
2505          void login_disp_3_star() {
2506   1          char str[64];
2507   1          sprintf(str, "m display_asterik_3\r");
2508   1          sendCommand(str);
2509   1      }
2510          
2511          // function code == 27
2512          void login_disp_4_star() {
2513   1          char str[64];
2514   1          sprintf(str, "m display_asterik_4\r");
2515   1          sendCommand(str);
2516   1          if(is_locked_out==0 && passcode[0]==1 && passcode[1]==2 && passcode[2]==3 && passcode[3]==4)
2517   1          {
2518   2            sprintf(userID, "J Lin");
2519   2            sprintf(str, "m set_uid %s\r", userID);
2520   2            sendCommand(str);
2521   2            sprintf(str, "m display_main_page\r");
2522   2            sendCommand(str);
2523   2            is_in_main_page=1;
2524   2          }
2525   1          else if(is_locked_out==0 && passcode[0]==9 && passcode[1]==9 && passcode[2]==9 && passcode[3]==9)
2526   1          {
2527   2            sprintf(userID, "S-H Yang");
2528   2            sprintf(str, "m set_uid %s\r", userID);
2529   2            sendCommand(str);
2530   2            sprintf(str, "m display_main_page\r");
2531   2            sendCommand(str);
2532   2            is_in_main_page=1;
2533   2          }
2534   1          else if(is_locked_out==0 && passcode[0]==1 && passcode[1]==1 && passcode[2]==1 && passcode[3]==1)
2535   1          {
2536   2            sprintf(userID, "Y Li");
2537   2            sprintf(str, "m set_uid %s\r", userID);
2538   2            sendCommand(str);
2539   2            sprintf(str, "m display_main_page\r");
2540   2            sendCommand(str);
2541   2            is_in_main_page=1;
2542   2          }
2543   1          else if(is_locked_out==1 && passcode[0]==6 && passcode[1]==7 && passcode[2]==8 && passcode[3]==9)
2544   1          {
2545   2            sprintf(userID, "C Davila");
2546   2            sprintf(str, "m set_uid %s\r", userID);
2547   2            sendCommand(str);
2548   2            sprintf(str, "m display_main_page\r");
2549   2            sendCommand(str);
2550   2            is_in_main_page=1;
2551   2          }
2552   1          else
2553   1          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 44  

2554   2            sprintf(str, "xi 40 0 0\r");
2555   2            sendCommand(str);
2556   2            sprintf(str, "xc all\r");
2557   2            sendCommand(str);
2558   2            sprintf(str, "w 1000\r");
2559   2            sendCommand(str);
2560   2            passcode[0]=-1;
2561   2            passcode[1]=-1;
2562   2            passcode[2]=-1;
2563   2            passcode[3]=-1;
2564   2            attempts--;
2565   2            if(attempts<=0)
2566   2            {
2567   3              is_locked_out=1;
2568   3              sprintf(str, "m display_locked_page\r");
2569   3              sendCommand(str);
2570   3            }
2571   2            else
2572   2            {
2573   3              sprintf(str, "m display_login_attempts_left %d\r", attempts);
2574   3              sendCommand(str);
2575   3            }
2576   2          }
2577   1      }
2578          // Login Page end =============
2579          
2580          // Locked out Page begin ======
2581          
2582          // function code == 31
2583          void locked_page_load() {
2584   1      
2585   1      }
2586          
2587          // function code == 32
2588          void update_wait_time() {
2589   1      
2590   1      }
2591          
2592          // function code == 33
2593          void login_clear_disp() {
2594   1      
2595   1      }
2596          // Locked out Page end ========
2597          
2598          void main_page_load()
2599          {
2600   1            char str[64];
2601   1            is_in_temp_page=0;
2602   1            is_in_motor_page=0;
2603   1            is_in_game=0;
2604   1            is_in_laser_page=0;
2605   1            is_in_setting_page=0;
2606   1            select=0;
2607   1            sprintf(str, "m display_main_page\r");
2608   1            sendCommand(str);
2609   1            is_in_main_page=1;
2610   1      }
2611          // finction code == 40
2612          
2613          void temp_page_load()
2614          {
2615   1            char str[64];
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 45  

2616   1            is_in_main_page=0;
2617   1            sprintf(str, "m display_temp_page\r");
2618   1            sendCommand(str);
2619   1            is_in_temp_page=1;
2620   1            if(is_in_c==0)
2621   1            {
2622   2              sprintf(str, "m temp_unit_f\r");
2623   2              sendCommand(str);
2624   2            }
2625   1            else
2626   1            {
2627   2              sprintf(str, "m temp_unit_c\r");
2628   2              sendCommand(str);
2629   2            }       
2630   1      }
2631          // finction code == 41
2632          
2633          void motor_page_load()
2634          {
2635   1            char str[64];
2636   1            is_in_main_page=0;
2637   1            point=0;
2638   1            stones=20;
2639   1            sprintf(str, "m display_game_page\r");
2640   1            sendCommand(str);
2641   1            is_in_motor_page=1;
2642   1      }
2643          // finction code == 42
2644          
2645          void laser_page_load()
2646          {
2647   1            char str[64];
2648   1            is_in_main_page=0;
2649   1            sprintf(str, "m display_laser_page\r");
2650   1            sendCommand(str);
2651   1            is_in_laser_page=1;
2652   1      
2653   1      }
2654          // finction code == 43
2655          
2656          void setting_page_load()
2657          {
2658   1            char str[64];
2659   1            is_in_main_page=0;
2660   1            sprintf(str, "m display_settings_screen %d %d\r", brightness, contrast);
2661   1            sendCommand(str);
2662   1            is_in_setting_page=1;
2663   1      }
2664          // finction code == 44
2665          
2666          void c_to_f()
2667          {
2668   1        is_in_c=0;
2669   1      }
2670          // finction code == 50
2671          
2672          void f_to_c()
2673          {
2674   1        is_in_c=1;
2675   1      }
2676          // finction code == 51
2677          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 46  

2678          void add_point()
2679          {
2680   1        point++;
2681   1      }
2682          // finction code == 52
2683          
2684          void game_start()
2685          {
2686   1        point=0;
2687   1        stones=20;
2688   1        is_in_game=1;
2689   1      }
2690          // finction code == 53
2691          
2692          void brightness_setting()
2693          {
2694   1        char str[64];
2695   1        sprintf(str, "m adjust_brightness %d\r", brightness);
2696   1        sendCommand(str);
2697   1      /*  
2698   1        if(brightness<10)
2699   1        {
2700   1          sprintf(str, "  %d", brightness);
2701   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2702   1        }
2703   1        else if(brightness<100)
2704   1        {
2705   1          sprintf(str, " %d", brightness);
2706   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2707   1        }
2708   1        else
2709   1        {
2710   1          sprintf(str, "%d", brightness);
2711   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2712   1        }
2713   1      */
2714   1      }
2715          // finction code == 54
2716          
2717          void time_setting()
2718          {
2719   1        char str[64];
2720   1        switch(select)
2721   1        {
2722   2            case 0: break;
2723   2            case 1: sprintf(str, "m display_date_time_slider %02bu 12 1\r", month); sendCommand(str); break;
2724   2            case 2: if(month==1 || month==3 ||month==5 || month==7 ||month==8 || month==10 || month==12)
2725   2                    {
2726   3                      sprintf(str, "m display_date_time_slider %02bu 31 1\r", date); sendCommand(str); break;
2727   3                    }
2728   2                    else if(month==4 || month==6 ||month==9 || month==11)
2729   2                    {
2730   3                      sprintf(str, "m display_date_time_slider %02bu 30 1\r", date); sendCommand(str); break;
2731   3                    }
2732   2                    else if(month==2 && year%4==0)
2733   2                    {
2734   3                      sprintf(str, "m display_date_time_slider %02bu 29 1\r", date); sendCommand(str); break;
2735   3                    }
2736   2                    else
2737   2                    {
2738   3                      sprintf(str, "m display_date_time_slider %02bu 28 1\r", date); sendCommand(str); break;
2739   3                    }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 47  

2740   2            case 3: sprintf(str, "m display_date_time_slider %02bu 99 0\r", year); sendCommand(str); break;
2741   2            case 4: sprintf(str, "m display_date_time_slider %02bu 12 1\r", hours); sendCommand(str); break;
2742   2            case 5: sprintf(str, "m display_date_time_slider %02bu 59 0\r", minutes); sendCommand(str); break;
2743   2            case 6: sprintf(str, "m display_date_time_slider %02bu 59 0\r", seconds); sendCommand(str); break;
2744   2            case 7: if(amPm=='P')
2745   2                    {
2746   3                      amPm='A'; 
2747   3                    }
2748   2                    else
2749   2                    {
2750   3                      amPm='P'; 
2751   3                    }
2752   2                    setClock(); 
2753   2                    break;
2754   2            default: break;
2755   2        }
2756   1      
2757   1      }
2758          // finction code == 55
2759          
2760          void set_clock()
2761          {
2762   1        char str[64];
2763   1        switch(select)
2764   1        {
2765   2            case 0: break;
2766   2            case 1: month=clock_value; break;
2767   2            case 2: date=clock_value; break;
2768   2            case 3: year=clock_value; break;
2769   2            case 4: hours=clock_value; break;
2770   2            case 5: minutes=clock_value; break;
2771   2            case 6: seconds=clock_value; break;
2772   2            case 7: break;
2773   2            default: break;
2774   2        }
2775   1        if(month==1 || month==2)                day=(date+1+2*(month+12)+3*((month+12)+1)/5+(year-1)+(year-1)/4-(year-1)/
             -100+(year-1)/400)%7;
2776   1        else                                    day=(date+1+2*month+3*(month+1)/5+year+year/4-year/100+year/400)%7;
2777   1        setClock();
2778   1      }
*** WARNING C280 IN LINE 2762 OF ..\mc_code\with_real_time_clock\main.c: 'str': unreferenced local variable
2779          // finction code == 56
2780          
2781          void contrast_setting()
2782          {
2783   1        char str[64];
2784   1        if(contrast<16)
2785   1        {
2786   2          sprintf(SETTINGS_DATE_FG, "000%X00", contrast);
2787   2          sprintf(SETTINGS_TIME_FG, "000%X00", contrast);
2788   2          sprintf(SETTINGS_DATE_BG, "%X%X%X", 255-contrast, 255-contrast, 255-contrast);
2789   2        }
2790   1        else if(contrast>239)
2791   1        {
2792   2          sprintf(SETTINGS_DATE_FG, "00%X00", contrast);
2793   2          sprintf(SETTINGS_TIME_FG, "00%X00", contrast);
2794   2          sprintf(SETTINGS_DATE_BG, "0%X0%X0%X", 255-contrast, 255-contrast, 255-contrast);
2795   2        }
2796   1        else
2797   1        {
2798   2          sprintf(SETTINGS_DATE_FG, "00%X00", contrast);
2799   2          sprintf(SETTINGS_TIME_FG, "00%X00", contrast);
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 11:59:49 PAGE 48  

2800   2          sprintf(SETTINGS_DATE_BG, "%X%X%X", 255-contrast, 255-contrast, 255-contrast);
2801   2        }
2802   1      }
*** WARNING C280 IN LINE 2783 OF ..\mc_code\with_real_time_clock\main.c: 'str': unreferenced local variable
2803          // finction code == 57


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12763    ----
   CONSTANT SIZE    =   1718    ----
   XDATA SIZE       =   3644    1780
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
