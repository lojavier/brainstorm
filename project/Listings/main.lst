C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\mc_code\with_real_time_clock\main.c LARGE OPTIMIZE(8,SPEED) BROWSE DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          //-------------------------------------------------------------------------------------------------------
   4          // Global Declarations
   5          //-------------------------------------------------------------------------------------------------------
   6          int SETTINGS_DATE_X =163;
   7          int SETTINGS_DATE_Y =393;
   8          
   9          unsigned char tsByte;
  10          
  11          bit splashEnd = 0;
  12          bit screenReset = 0;
  13          bit ackFromScreen = 0;
  14          bit tsCommandReceived = 0;
  15          bit tsCommandTransmitted = 0;
  16          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  17          
  18          unsigned char sharedDataRx[SHARED_DATA_MAX];
  19          unsigned char sharedDataTx[SHARED_DATA_MAX];
  20          unsigned char eepromTx[EEPROM_TX_BUFFER];
  21          unsigned char eepromRx[EEPROM_RX_BUFFER];
  22          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  23          
  24          unsigned int pageCount;
  25          unsigned int bytesExtra;
  26          unsigned int eepromPageCounter;
  27          unsigned int startAddr;
  28          unsigned char slaveAddr;                                                // Target SMBus slave address
  29          unsigned char eepromDataByte;
  30          
  31          unsigned int numBytesRD;
  32          unsigned int numBytesWR;
  33          unsigned char slaveWriteDone;
  34          unsigned char slaveReadDone;
  35          unsigned char eepromWriteDone;
  36          unsigned char eepromReaddone;
  37          unsigned char rtcWriteDone;
  38          unsigned char rtcReadDone;
  39          
  40          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  41          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  42          unsigned char userCommand[RX_BUFFER_SIZE];
  43          
  44          unsigned int tsRxIn;
  45          unsigned int tsRxOut; 
  46          unsigned int tsTxIn;
  47          unsigned int tsTxOut;
  48          
  49          bit tsRxEmpty;
  50          bit tsTxEmpty;
  51          bit tsLastCharGone; 
  52          
  53          bit screenChanged;
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 2   

  54          unsigned char screen;
  55          unsigned char lastScreen;
  56          
  57          const char code * Font[] = {/*0*/ "m10B", 
  58                        /*1*/ "m12B",
  59                        /*2*/ "m14B",
  60                        /*3*/ "m16B",
  61                        /*4*/ "m20B",
  62                        /*5*/ "m24B",
  63                        /*6*/ "m32B",
  64                        /*7*/ "m48",
  65                        /*8*/ "m64"};
  66          
  67          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  68          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  69          
  70          unsigned int startAddr;
  71          unsigned char slaveAddr;                                                // Target SMBus slave address
  72          
  73          unsigned int numBytesRD;
  74          unsigned int numBytesWR;
  75          
  76          unsigned char slaveWriteDone;
  77          unsigned char slaveReadDone;
  78                                      
  79          unsigned char roomTemp1;
  80          unsigned char roomTemp2;
  81          unsigned char roomTemp3;
  82                                      
  83          unsigned char seconds;
  84          unsigned char minutes;
  85          unsigned char hours;
  86          unsigned char hours24;
  87          unsigned char amPm;
  88          unsigned char day;
  89          unsigned char date;
  90          unsigned char month;
  91          unsigned char year;
  92          unsigned char century;
  93          unsigned char timeMode;
  94          unsigned char currentIndex = 0;
  95          unsigned char minuteIndex = 0;
  96          unsigned char hourIndex = 0;
  97          
  98          unsigned char currentDate;
  99          unsigned char currentMonth;
 100          unsigned char currentYear;
 101          
 102          unsigned char realTimeClockItems;
 103          
 104          unsigned char adjustedSeconds;
 105          unsigned char adjustedMinutes;
 106          unsigned char adjustedHours;
 107          unsigned char adjustedAmPm;
 108          unsigned char adjustedDay;
 109          unsigned char adjustedDate;
 110          unsigned char adjustedMonth;
 111          unsigned char adjustedYear;
 112          unsigned char adjustedCentury;
 113          unsigned char adjustedTimeMode;
 114          
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 3   

 115          bit monthUpdated;
 116          bit dateUpdated;
 117          bit yearUpdated;
 118          bit hoursUpdated;
 119          bit minutesUpdated;
 120          bit secondsUpdated;
 121          bit amPmUpdated;
 122          bit timeUpdated;
 123          bit monthDateYearUpdated;
 124          
 125          const char code * dayOfWeek[] =   {
 126                             /*0*/  "SUN",
 127                             /*1*/  "MON", 
 128                             /*2*/  "TUE",
 129                             /*3*/  "WED", 
 130                             /*4*/  "THU",
 131                             /*5*/  "FRI", 
 132                             /*6*/  "SAT"}; 
 133          
 134          const char code * monthOfYear[] =   {/*0*/  "NON",
 135                             /*1*/  "JAN",
 136                             /*2*/  "FEB", 
 137                             /*3*/  "MAR",
 138                             /*4*/  "APR", 
 139                             /*5*/  "MAY",
 140                             /*6*/  "JUN", 
 141                             /*7*/  "JUL",
 142                             /*8*/  "AUG",
 143                             /*9*/  "SEP",
 144                             /*10*/ "OCT", 
 145                             /*11*/ "NOV",
 146                             /*12*/ "DEC"};
 147          
 148          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 149                            /*1*/ "WRITING DATA... WAIT!  ",
 150                            /*2*/ "DATA SUCCESSFULLY SAVED",
 151                            /*3*/ "ERROR                  "};
 152          
 153          //-------------------------------------------------------------------------------------------------------
 154          // System Configurations
 155          //-------------------------------------------------------------------------------------------------------
 156          void systemClockInit(void)
 157          {
 158   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 159   1        int i = 0;
 160   1          
 161   1        SFRPAGE  = CONFIG_PAGE;
 162   1        
 163   1          OSCICN    = 0x83;
 164   1      
 165   1        SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 166   1      }
 167          
 168          void portInit(void)
 169          {
 170   1        char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 171   1      
 172   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
 173   1      
 174   1        XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                      
 175   1          XBR1 = 0x01;                    
 176   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up                       
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 4   

 177   1          
 178   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 179   1                                              // TX0 = P0.0; RX0 = P0.1
 180   1        P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 181   1                                              // TX1 = P1.0; RX1 = P1.1
 182   1        P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pull
 183   1        
 184   1        P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 185   1                                              
 186   1        P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 187   1        
 188   1        P6MDOUT = 0x00;
 189   1                                                                                    
 190   1        P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 191   1        
 192   1        P0 = 0xFF;                                  // Initialize port P0 latch
 193   1        P1 = 0xFF;                                  // Initialize port P1 latch
 194   1        P2 = 0xFF;                                  // Initialize port P2 latch
 195   1        P3 = 0xFF;                                  // Initialize port P3 latch
 196   1        P4 = 0xFF;                                  // Initialize port P4 latch
 197   1        P5 = 0xFF;                                  // Initialize port P5 latch
 198   1        P6 = 0xFF;                                  // Initialize port P6 latch
 199   1        P7 = 0xFF;                                  // Initialize port P7 latch
 200   1      
 201   1        RHW = 0;                                  // Pull low SMB error line
 202   1      
 203   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 204   1      }
 205          
 206          void enableInterrupts(void)
 207          {
 208   1        IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 209   1        EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 210   1        EIE2 |= 0x40;                               // Enable UART1 interrupt
 211   1        EIE1 |= 0x0A;                               // Enable SMBus interrupt
 212   1      }
 213          
 214          void uart0Init(void)
 215          {
 216   1         char SFRPAGE_SAVE;
 217   1      
 218   1         SFRPAGE_SAVE = SFRPAGE;                                              // Preserve SFRPAGE
 219   1      
 220   1         SFRPAGE = TMR2_PAGE;
 221   1         TMR2CN = 0x00;                                                       // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 222   1         TMR2CF = 0x08;                                                       // SYSCLK is time base; no output; up 
             -count only
 223   1         RCAP2L = 0xF3;                                                               // Low byte
 224   1         RCAP2H = 0xFF;                                                               // High byte
 225   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 226   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 227   1      
 228   1         SFRPAGE = UART0_PAGE;
 229   1         SCON0 = 0x50;                                                        // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 230   1         SSTA0 = 0x05;                                                        // Enable baud rate                   
             -                                                
 231   1                                                                              // Use timer 2 as RX and TX baud rate 
             -source
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 5   

 232   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 233   1      
 234   1         SFRPAGE = SFRPAGE_SAVE;                                              // Restore SFRPAGE
 235   1      }
 236          
 237          void disableWatchdog(void)
 238          {
 239   1        WDTCN = 0xDE;                                               // Disable watchdog timer
 240   1          WDTCN = 0xAD;
 241   1      }
 242          
 243          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 244          {
 245   1          char SFRPAGE_SAVE = SFRPAGE;
 246   1        unsigned int i = 0;
 247   1        unsigned long txWaitCounter = 0;
 248   1      
 249   1        SFRPAGE = UART0_PAGE;
 250   1      
 251   1          if(RI0 == 1)                                                        // There is a char in SBUF
 252   1          {
 253   2            RI0 = 0;                                                    // Clear interrupt flag
 254   2      
 255   2            tsByte = SBUF0;                                             // Read a character from UART
 256   2      
 257   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 258   2              {
 259   3                if(tsByte != '\r')                          // Check end of a command from touch screen
 260   3            {
 261   4              tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 262   4              tsRxIn++;                           // Increment index
 263   4            }
 264   3                else                                // If it is CR character, it marks end of command
 265   3            {                               
 266   4              if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 267   4              {
 268   5                if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 269   5                {
 270   6                  splashEnd = 1;                                        // Detect end of splash screen
 271   6                  screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 272   6                }
 273   5                else
 274   5                {
 275   6                  splashEnd = 0;                                          // End of splash screen NOT detected
 276   6                  screenReset = 0;                  
 277   6                }
 278   5              }
 279   4              else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 280   4              {                               // A command starts with '('
 281   5                for(i = 0; i < tsRxIn; i++)
 282   5                {
 283   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 284   6                }
 285   5      
 286   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 287   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 288   5              }
 289   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == 'o' && tsRxBuffer[2] == 'a')                   // It is a comm
             -and from touch screen controller
 290   4              {                               // A command starts with '('
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 6   

 291   5                for(i = 0; i < tsRxIn; i++)
 292   5                {
 293   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 294   6                }
 295   5                userCommand[tsRxIn]='\0';
 296   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 297   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 298   5              }
 299   4              else if(tsRxBuffer[0] == 's' && tsRxBuffer[1] == 't' && tsRxBuffer[2] == 'a')                   // It is a comm
             -and from touch screen controller
 300   4              {                               // A command starts with '('
 301   5                for(i = 0; i < tsRxIn; i++)
 302   5                {
 303   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 304   6                }
 305   5                userCommand[tsRxIn]='\0';
 306   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 307   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 308   5              }
 309   4              else if(tsRxBuffer[0] == 'g' && tsRxBuffer[1] == 'e' && tsRxBuffer[2] == 't')                   // It is a comm
             -and from touch screen controller
 310   4              {                               // A command starts with '('
 311   5                for(i = 0; i < tsRxIn; i++)
 312   5                {
 313   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 314   6                }
 315   5                userCommand[tsRxIn]='\0';
 316   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 317   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 318   5              }
 319   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == '2' && tsRxBuffer[2] == '4')                   // It is a comm
             -and from touch screen controller
 320   4              {                               // A command starts with '('
 321   5                for(i = 0; i < tsRxIn; i++)
 322   5                {
 323   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 324   6                }
 325   5                userCommand[tsRxIn]='\0';
 326   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 327   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 328   5              }
 329   4              else if(tsRxBuffer[0] == 'l' && tsRxBuffer[1] == 'p' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 330   4              {                               // A command starts with '('
 331   5                for(i = 0; i < tsRxIn; i++)
 332   5                {
 333   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 334   6                }
 335   5                userCommand[tsRxIn]='\0';
 336   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 337   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 338   5              }
 339   4              else if(tsRxBuffer[0] == 'e' && tsRxBuffer[1] == 'n' && tsRxBuffer[2] == 'd')                   // It is a comm
             -and from touch screen controller
 340   4              {                               // A command starts with '('
 341   5                for(i = 0; i < tsRxIn; i++)
 342   5                {
 343   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 344   6                }
 345   5                userCommand[tsRxIn]='\0';
 346   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 347   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 7   

 348   5              }
 349   4              else if(tsRxBuffer[0] == 'm' && tsRxBuffer[1] == 'p' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 350   4              {                               // A command starts with '('
 351   5                for(i = 0; i < tsRxIn; i++)
 352   5                {
 353   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 354   6                }
 355   5                userCommand[tsRxIn]='\0';
 356   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 357   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 358   5              }
 359   4              else if(tsRxBuffer[0] == 'n' && tsRxBuffer[1] == 's' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 360   4              {                               // A command starts with '('
 361   5                for(i = 0; i < tsRxIn; i++)
 362   5                {
 363   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 364   6                }
 365   5                userCommand[tsRxIn]='\0';
 366   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 367   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 368   5              }
 369   4              else if(tsRxBuffer[0] == 'd' && tsRxBuffer[1] == 't' && tsRxBuffer[2] == '_')                   // It is a comm
             -and from touch screen controller
 370   4              {                               // A command starts with '('
 371   5                for(i = 0; i < tsRxIn; i++)
 372   5                {
 373   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 374   6                }
 375   5                userCommand[tsRxIn]='\0';
 376   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 377   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 378   5              }
 379   4              else                              // Not a command from touch screen controller
 380   4              {
 381   5                ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 382   5                tsCommandReceived = 0;                    // No need to set flag because it is not a command
 383   5              }
 384   4      
 385   4              for(i = 0; i < tsRxIn; i++)
 386   4              {
 387   5                tsRxBuffer[i] = '\0';                   // Delete all contents
 388   5              }
 389   4              
 390   4              tsRxOut = 0;                          // Reset index Out
 391   4              tsRxIn = 0;                           // Reset index In
 392   4            } 
 393   3              }
 394   2          else                                  // Reset all indexes
 395   2          { 
 396   3            while(tsRxOut < tsRxIn)
 397   3            {
 398   4              tsRxBuffer[tsRxOut] = '\0';
 399   4              tsRxOut++;
 400   4            }
 401   3            tsRxOut = 0;
 402   3            tsRxIn = 0;
 403   3            tsCommandReceived = 0;
 404   3          }
 405   2         }
 406   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 8   

 407   1         if(TI0 == 1)                                                 // Check if one character is successfully sent out
 408   1         {
 409   2              TI0 = 0;                                                    // Clear interrupt flag
 410   2      
 411   2          if(tsTxEmpty == 0)                            // TX buffer has something to send
 412   2          {
 413   3            SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 414   3            tsTxOut++;                              // Move to next character
 415   3      
 416   3            while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmission TI0 = 
             -1
 417   3            if(txWaitCounter >= TX_WAIT_LIMIT)
 418   3            {
 419   4              TI0 = 1;                            // TI0 is not set by hardware, set it by software
 420   4            }                                 // When TI0 is set to 1, this ISR is executed again
 421   3            
 422   3            txWaitCounter = 0;                          // Reset counter for next execution 
 423   3      
 424   3            if(tsTxOut >= TX_BUFFER_SIZE)
 425   3            {
 426   4              tsTxOut = 0;                          // Reset index to 0
 427   4            }               
 428   3      
 429   3            if(tsTxOut == tsTxIn)                       // If two indexes are equal
 430   3            {
 431   4              tsTxEmpty = 1;                          // No more character in buffer. Empty
 432   4            }
 433   3          }
 434   2          else
 435   2          {
 436   3            tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 437   3          }
 438   2          }
 439   1        
 440   1        SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 441   1      }
 442          
 443          //-------------------------------------------------------------------------------------------------------
 444          // Function Name: sendCommand
 445          // Return Value: None 
 446          // Parmeters: s (a string to send)
 447          // Function Description: This function sends a command from the touch screen
 448          //-------------------------------------------------------------------------------------------------------
 449          void sendCommand(const char * s)
 450          { 
 451   1        char SFRPAGE_SAVE = SFRPAGE;
 452   1        
 453   1        while(*s != '\0')                             // Search for end of touch screen command in buffer
 454   1          {
 455   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 456   2          {
 457   3            tsTxBuffer[tsTxIn++] = *s;
 458   3            if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 459   3            {
 460   4              tsTxIn = 0;                           // Reset if limit reached
 461   4            }
 462   3      
 463   3            if(tsTxEmpty == 1)                          // If buffer is empty
 464   3            {
 465   4              tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 466   4            }
 467   3          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 9   

 468   2            
 469   2          s++;                                  // Point to next char to send out
 470   2          }
 471   1                                              
 472   1        if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 473   1        {
 474   2          tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 475   2          SFRPAGE = UART0_PAGE;                                     
 476   2          TI0 = 1;                                                            // Set this flage to call ISR to send 
             -out one character
 477   2        }                                     
 478   1                                              
 479   1        SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 480   1      }
 481          
 482          //-------------------------------------------------------------------------------------------------------
 483          // Function Name: displayText
 484          // Return Value: None 
 485          // Parmeters: fg, bg, size, message, x, y
 486          // Function Description: This function displays a text on the touch screen
 487          //-------------------------------------------------------------------------------------------------------
 488          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 489          {
 490   1        char str[TS_BUFFER_SIZE];                         // String
 491   1          
 492   1        sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 493   1        sendCommand(str);                           
 494   1        sprintf(str, "f %s\r", Font[size]);                     // Set text font
 495   1        sendCommand(str);                           
 496   1        sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
 497   1        sendCommand(str);                           
 498   1      }
 499          
 500          //-------------------------------------------------------------------------------------------------------
 501          // Function Name: showBitmap
 502          // Return Value: None 
 503          // Parmeters: index, x, y (bitmap index and coordinates)
 504          // Function Description: This function displays a bitmap image
 505          //-------------------------------------------------------------------------------------------------------
 506          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 507          {
 508   1        char str[TS_BUFFER_SIZE];
 509   1      
 510   1        sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 511   1        sendCommand(str);
 512   1      }
 513          
 514          //-------------------------------------------------------------------------------------------------------
 515          // Function Name: changeScreen
 516          // Return Value: None 
 517          // Parmeters: screenIndex (macro number)
 518          // Function Description: This function switches to the new screen
 519          //-------------------------------------------------------------------------------------------------------
 520          void changeScreen(const unsigned char screenIndex)
 521          {
 522   1        callMacro(screenIndex);                           // Change screen    
 523   1      }
 524          
 525          //-------------------------------------------------------------------------------------------------------
 526          // Function Name: callMacro
 527          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 10  

 528          // Parmeters: macroNumber (macro number in the macro file)
 529          // Function Description: This function calls a macro
 530          //-------------------------------------------------------------------------------------------------------
 531          void callMacro(const unsigned int macroNumber)
 532          {
 533   1        char str[TS_BUFFER_SIZE];
 534   1      
 535   1        sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 536   1        sendCommand(str);
 537   1      }
 538          
 539          //-------------------------------------------------------------------------------------------------------
 540          // Function Name: scanUserInput
 541          // Return Value: None 
 542          // Parmeters: None
 543          // Function Description: This function processes commands from the touch screen
 544          //-------------------------------------------------------------------------------------------------------
 545          void scanUserInput(void)
 546          { 
 547   1        int i = 0;
 548   1      
 549   1        if(screen == MAIN_PAGE)                           // Main screen
 550   1        {    
 551   2          if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 552   2          {
 553   3            switch (userCommand[1])                         // Scan a command type
 554   3            {
 555   4              case '1':                           // Main page
 556   4                changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 557   4                break;
 558   4              case '2':                           // Settings page
 559   4                changeScreen(SETTINGS_PAGE);
 560   4                break;
 561   4              case '3':                             // Service page
 562   4                changeScreen(SERVICE_PAGE);
 563   4                break;
 564   4              case 'A':
 565   4                // Call a function here or do something here      
 566   4                break;
 567   4              case 'B':
 568   4                // Call a function here or do something here
 569   4                break;
 570   4              case 'C':
 571   4                // Call a function here or do something here
 572   4                break;  
 573   4              default:                            // Other options
 574   4                break;
 575   4              }
 576   3          }
 577   2          else                                  // Not a command, empty buffer with null char
 578   2          {
 579   3            i = 0;
 580   3            while(userCommand[i] != '\0')
 581   3            {
 582   4              userCommand[i] = '\0';
 583   4              i++;
 584   4            }
 585   3          } 
 586   2        }
 587   1        else if(screen == SETTINGS_PAGE)                      // Settings page
 588   1        {
 589   2          if(userCommand[0] == '(')
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 11  

 590   2          {
 591   3            switch (userCommand[1])
 592   3            {
 593   4              case '1':
 594   4                changeScreen(MAIN_PAGE);
 595   4                break;
 596   4              case '2':
 597   4                changeScreen(SETTINGS_PAGE);
 598   4                break;
 599   4              case '3':
 600   4                changeScreen(SERVICE_PAGE);
 601   4                break;
 602   4              case 'A':
 603   4                // Call a function here or do something here
 604   4                break;
 605   4              case 'B':
 606   4                  // Call a function here or do something here
 607   4                break;
 608   4              case 'C':
 609   4                  // Call a function here or do something here
 610   4                break;
 611   4              default:
 612   4                break;
 613   4            }
 614   3          }
 615   2          else                                  // Not a command, empty buffer with null
 616   2          {
 617   3            i = 0;
 618   3            while(userCommand[i] != '\0')
 619   3            {
 620   4              userCommand[i] = '\0';
 621   4              i++;
 622   4            }
 623   3          }       
 624   2        }
 625   1        else if(screen == SERVICE_PAGE)
 626   1        {
 627   2          if(userCommand[0] == '(')
 628   2          {
 629   3            switch (userCommand[1])
 630   3            {
 631   4              case '1':
 632   4                changeScreen(MAIN_PAGE);
 633   4                break;
 634   4              case '2':
 635   4                changeScreen(SETTINGS_PAGE);
 636   4                break;
 637   4              case '3':
 638   4                changeScreen(SERVICE_PAGE);
 639   4                break;
 640   4              case 'A':
 641   4                // Call a function here or do something here
 642   4              case 'B':
 643   4                // Call a function here or do something here
 644   4              case 'C':
 645   4                // Call a function here or do something here
 646   4              default:
 647   4                break;
 648   4            }
 649   3          }
 650   2          else                                  // Not a command, empty buffer with null
 651   2          {                               
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 12  

 652   3            i = 0;
 653   3            while(userCommand[i] != '\0')
 654   3            {
 655   4              userCommand[i] = '\0';
 656   4              i++;
 657   4            }
 658   3          }       
 659   2        } 
 660   1        else
 661   1        {
 662   2      
 663   2        }
 664   1      
 665   1        i = 0;
 666   1        while(userCommand[i] != '\0')
 667   1        {
 668   2          userCommand[i] = '\0';                          // Delete all contents in array
 669   2          i++;
 670   2        }
 671   1      }
 672          
 673          //-------------------------------------------------------------------------------------------------------
 674          // Function Name: smbInit
 675          // Return Value: None 
 676          // Parmeters: None
 677          // Function Description: This function initializes the SMB bus 
 678          //-------------------------------------------------------------------------------------------------------
 679          void smbInit(void)
 680          {
 681   1          int i;
 682   1        unsigned long pollingCounter = 0;
 683   1        char SFRPAGE_SAVE = SFRPAGE;
 684   1      
 685   1          SFRPAGE = SMB0_PAGE;
 686   1        while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because of e
             -rror or reset
 687   1          {
 688   2              SCL = 0;                                                          // Drive the clock low
 689   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 690   2              SCL = 1;                                                          // Release the clock
 691   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
 692   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
 693   2          }
 694   1            
 695   1        SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 696   1                                                                              // Enable SMBus Free timeout detect;
 697   1        SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and Thi
             -gh equations
 698   1                                        
 699   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 700   1      
 701   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 702   1        
 703   1        SMB_BUSY = 0;
 704   1                                                                                          // Release SMB
 705   1          slaveWriteDone = FALSE;
 706   1        slaveReadDone = FALSE;
 707   1        eepromWriteDone = FALSE;
 708   1        eepromReadDone = FALSE;
 709   1        rtcWriteDone = FALSE;
 710   1        rtcReadDone = FALSE;
 711   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 13  

 712          
 713          //-------------------------------------------------------------------------------------------------------
 714          // Function Name: timer3Init
 715          // Return Value: None 
 716          // Parmeters: None
 717          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 718          //-------------------------------------------------------------------------------------------------------
 719          void timer3Init (void)
 720          {
 721   1          char SFRPAGE_SAVE = SFRPAGE;        
 722   1      
 723   1          SFRPAGE = TMR3_PAGE;
 724   1      
 725   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 726   1                                                // Timer 3 auto reload
 727   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 728   1      
 729   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 730   1          TMR3 = RCAP3;                                                     
 731   1      
 732   1          TR3 = 1;                                                            // Start Timer 3
 733   1      
 734   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 735   1      }
 736          
 737          //-------------------------------------------------------------------------------------------------------
 738          // Function Name: timer3ISR
 739          // Return Value: None 
 740          // Parmeters: None
 741          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 742          //-------------------------------------------------------------------------------------------------------
 743          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 744          {
 745   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 746   1      
 747   1          SFRPAGE = SMB0_PAGE;
 748   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 749   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 750   1      
 751   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
 752   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 753   1          SMB_BUSY = 0;                                                       // Free bus
 754   1         
 755   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 756   1      }
 757          
 758          //-------------------------------------------------------------------------------------------------------
 759          // Function Name: writeOneByteToSlave
 760          // Return Value: None 
 761          // Parmeters: target, startAddr, content
 762          // Function Description: This function writes one to the slave microprocessor
 763          //-------------------------------------------------------------------------------------------------------
 764          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 765          {       
 766   1        sharedDataTx[startAddr] = content;
 767   1        smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 768   1      }
 769          
 770          //-------------------------------------------------------------------------------------------------------
 771          // Function Name: readOneByteFromSlave
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 14  

 772          // Return Value: long 
 773          // Parmeters: startAddr, bytes
 774          // Function Description: This function reads one from the slave microprocessor
 775          //-------------------------------------------------------------------------------------------------------
 776          unsigned char readOneByteFromSlave(unsigned char startAddr)
 777          {
 778   1        smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 779   1        return sharedDataRx[startAddr];                                               
 780   1      }
 781          
 782          //-------------------------------------------------------------------------------------------------------
 783          // Function Name: writeBytesToRealTimeClock
 784          // Return Value: None 
 785          // Parmeters: target, startAddr, bytes
 786          // Function Description: This function writes data byte to the real time clock DS3232
 787          //-------------------------------------------------------------------------------------------------------
 788          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 789          {
 790   1        smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 791   1      }
 792          
 793          //-------------------------------------------------------------------------------------------------------
 794          // Function Name: readBytesFromRealTimeClock
 795          // Return Value: None 
 796          // Parmeters: target, startAddr, bytes
 797          // Function Description: This function reads data byte from the real time clock DS3232
 798          //-------------------------------------------------------------------------------------------------------
 799          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 800          {
 801   1        smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 802   1      }
 803          
 804          //-------------------------------------------------------------------------------------------------------
 805          // Function Name: smbRead
 806          // Return Value: unsigned char * 
 807          // Parmeters: target, startAddr, bytes
 808          // Function Description: This function reads from SM bus
 809          //-------------------------------------------------------------------------------------------------------
 810          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 811          {
 812   1        char SFRPAGE_SAVE = SFRPAGE;
 813   1      
 814   1        SFRPAGE = SMB0_PAGE;
 815   1        
 816   1        while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 817   1      
 818   1        SFRPAGE = SFRPAGE_SAVE;
 819   1          
 820   1          switch(deviceId)
 821   1          {
 822   2              case MCU_SLAVE_ADDR:
 823   2              case REAL_TIME_CLOCK_ADDR:
 824   2              case EEPROM_ADDR:
 825   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 826   2                  break;
 827   2              default:
 828   2                  break;  
 829   2          }
 830   1      
 831   1          SFRPAGE = SMB0_PAGE;
 832   1          
 833   1          while(BUSY || SMB_BUSY);
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 15  

 834   1          slaveAddr = deviceId;                                                     // Address of MCU slave
 835   1          startAddr = location;                                 // Starting address to read from slave
 836   1          numBytesRD = bytes;                                   // Number of bytes to read
 837   1          
 838   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
 839   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
 840   1          STA = 1;
 841   1      
 842   1        while(BUSY || SMB_BUSY);                                                    // Wait for SMB
 843   1          
 844   1        SFRPAGE = SFRPAGE_SAVE;
 845   1            
 846   1          switch(deviceId)
 847   1          {
 848   2              case MCU_SLAVE_ADDR:
 849   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
 850   2                  break;
 851   2              case REAL_TIME_CLOCK_ADDR:
 852   2            while(rtcReadDone == 0);                                            // Wait until real time clock write c
             -ompleted or timeout occurs
 853   2            break;
 854   2              case EEPROM_ADDR:
 855   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
 856   2                  break;
 857   2              default:
 858   2                  break;  
 859   2          }  
 860   1      }
 861          
 862          //-------------------------------------------------------------------------------------------------------
 863          // Function Name: smbWrite
 864          // Return Value: unsigned char * 
 865          // Parmeters: target, startAddr, bytes
 866          // Function Description: This function reads to SM bus
 867          //-------------------------------------------------------------------------------------------------------
 868          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 869          {
 870   1        unsigned char i = 0;
 871   1        unsigned int pageWrittenDelay = 0;
 872   1        char SFRPAGE_SAVE = SFRPAGE;
 873   1          
 874   1        SFRPAGE = SMB0_PAGE;
 875   1        
 876   1        while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
 877   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
 878   1          startAddr = location;                               // Starting address to write to slave
 879   1      
 880   1          switch(deviceId)
 881   1          {
 882   2              case MCU_SLAVE_ADDR:                              // Pass through
 883   2              case DEVICE_DUMP_ADDR:                              // Pass through
 884   2                  numBytesWR = bytes;                             // Number of bytes to read
 885   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 886   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 887   2                  STA = 1;                                                          // Start transfer
 888   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 889   2                  break;
 890   2              case REAL_TIME_CLOCK_ADDR:
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 16  

 891   2                  numBytesWR = bytes;                             // Number of bytes to read
 892   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 893   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 894   2                  STA = 1;                                                          // Start transfer
 895   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
 896   2                  break;
 897   2              default:
 898   2                  break;    
 899   2        }
 900   1      
 901   1        SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
 902   1      }
 903          
 904          //-------------------------------------------------------------------------------------------------------
 905          // Function Name: smbISR
 906          // Return Value: None 
 907          // Parmeters: None
 908          // Function Description: 
 909          // SMBus Interrupt Service Routine (ISR)
 910          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 911          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 912          //-------------------------------------------------------------------------------------------------------
 913          void smbISR (void) interrupt INTERRUPT_SMB using 2
 914          {
 915   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
 916   1          static unsigned int TxCounter;                          // Initialize counter
 917   1          static unsigned int RxCounter;                          // Initialize counter
 918   1        static unsigned int slaveCount = 0;
 919   1        static unsigned int realTimeClockCount = 0;
 920   1        static unsigned int eepromCount = 0;
 921   1        static unsigned char eepromAddrDone;
 922   1        
 923   1        switch (SMB0STA >> 3)                             // Check SMB bus status
 924   1          {
 925   2      //-------------------------------------------------------------------------------------------------------
 926   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
 927   2      //-------------------------------------------------------------------------------------------------------
 928   2              case SMB_START:                               // Master initiates a transfer
 929   2      
 930   2      //-------------------------------------------------------------------------------------------------------
 931   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 932   2      //-------------------------------------------------------------------------------------------------------
 933   2              case SMB_REPEAT_START:
 934   2            SMB0DAT = slaveAddr;                                            // Load address of the slave.
 935   2                SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for the
             - R/W bit
 936   2                SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
 937   2            STA = 0;                                                      // Manually clear STA bit
 938   2      
 939   2                RxCounter = 0;                                                // Reset the counter
 940   2                TxCounter = 0;                                                // Reset the counter
 941   2            eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address  
 942   2                
 943   2            break;
 944   2      
 945   2      //-------------------------------------------------------------------------------------------------------
 946   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 17  

 947   2      // For a WRITE: Send the first data byte to the slave
 948   2      //-------------------------------------------------------------------------------------------------------
 949   2              case SMB_ADDR_W_TX_ACK_RX:
 950   2            if(slaveAddr == MCU_SLAVE_ADDR)
 951   2            {
 952   3              if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence only
 953   3              {
 954   4                STO = 1;                            // Stop this transfer
 955   4                SMB_BUSY = 0;                         // Releas SMB
 956   4              }
 957   3              else
 958   3              {
 959   4                SMB0DAT = startAddr;                      // Send 1 byte address to slave
 960   4                slaveWriteDone = 0;                       // Mark start of slave write
 961   4              }
 962   3            }
 963   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 964   2            {
 965   3              SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
 966   3              rtcWriteDone = 0;                         // Mark start of rtc write
 967   3            }
 968   2                  else{}
 969   2                break;
 970   2      
 971   2      //-------------------------------------------------------------------------------------------------------
 972   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 973   2      //-------------------------------------------------------------------------------------------------------
 974   2              case SMB_ADDR_W_TX_NACK_RX:
 975   2            if(slaveAddr == MCU_SLAVE_ADDR)
 976   2            {
 977   3              if(slaveCount < MAX_NACK_RETRY)
 978   3              {
 979   4                slaveCount++;                         // Increment number of attempts when NACK is received
 980   4                STA = 1;                            // Restart a new transfer
 981   4              }
 982   3              else
 983   3              {
 984   4                slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
 985   4                slaveWriteDone = 1;
 986   4                STO = 1;
 987   4                SMB_BUSY = 0;
 988   4                FAIL = 1;
 989   4              } 
 990   3            }
 991   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 992   2            {
 993   3              if(realTimeClockCount < MAX_NACK_RETRY)
 994   3              {
 995   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
 996   4                STA = 1;                            // Restart a new transfer
 997   4              }
 998   3              else
 999   3              {
1000   4                realTimeClockCount = 0;
1001   4                rtcWriteDone = 1;
1002   4                STO = 1;
1003   4                SMB_BUSY = 0;
1004   4                FAIL = 1;
1005   4              } 
1006   3            }
1007   2            else if(slaveAddr == EEPROM_ADDR)
1008   2            {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 18  

1009   3              if(eepromCount < MAX_NACK_RETRY)
1010   3              {
1011   4                eepromCount++;                          // Increment number of attempts when NACK is received
1012   4                STA = 1;                            // Restart a new transfer
1013   4              }
1014   3              else
1015   3              {
1016   4                eepromCount = 0;
1017   4                eepromWriteDone = 1;
1018   4                STO = 1;
1019   4                SMB_BUSY = 0;
1020   4                FAIL = 1;
1021   4              } 
1022   3            }
1023   2            else
1024   2            {}
1025   2      
1026   2                break;
1027   2      
1028   2      //-------------------------------------------------------------------------------------------------------
1029   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
1030   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
1031   2      //-------------------------------------------------------------------------------------------------------
1032   2              case SMB_DATA_TX_ACK_RX:
1033   2                if(slaveAddr == MCU_SLAVE_ADDR)
1034   2            {
1035   3              if(TxCounter < numBytesWR)
1036   3                  {
1037   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1038   4                      TxCounter++;
1039   4                  }
1040   3                  else
1041   3                  {
1042   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1043   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1044   4                slaveWriteDone = 1;                       // Mark end of slave write
1045   4                  }
1046   3            }
1047   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1048   2            {
1049   3              if(TxCounter < numBytesWR)
1050   3                  {
1051   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1052   4                      TxCounter++;
1053   4                  }
1054   3                  else
1055   3                  {
1056   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1057   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1058   4                rtcWriteDone = 1;                       // Mark end of slave write
1059   4                  }
1060   3            }
1061   2                break;
1062   2      
1063   2      //-------------------------------------------------------------------------------------------------------
1064   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1065   2      //-------------------------------------------------------------------------------------------------------
1066   2              case SMB_DATA_TX_NACK_RX:
1067   2            if(slaveAddr == MCU_SLAVE_ADDR)
1068   2            {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 19  

1069   3              if(slaveCount < MAX_NACK_RETRY)
1070   3              {
1071   4                slaveCount++;                         // Increment number of attempts when NACK is received
1072   4                STA = 1;                            // Restart a new transfer
1073   4              }
1074   3              else
1075   3              {
1076   4                slaveCount = 0;
1077   4                STO = 1;
1078   4                SMB_BUSY = 0;
1079   4                FAIL = 1;
1080   4              } 
1081   3            }
1082   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1083   2            {
1084   3              if(realTimeClockCount < MAX_NACK_RETRY)
1085   3              {
1086   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1087   4                STA = 1;                            // Restart a new transfer
1088   4              }
1089   3              else
1090   3              {
1091   4                realTimeClockCount = 0;
1092   4                STO = 1;
1093   4                SMB_BUSY = 0;
1094   4                FAIL = 1;
1095   4              } 
1096   3            }
1097   2            else if(slaveAddr == EEPROM_ADDR)
1098   2            {
1099   3              if(eepromCount < MAX_NACK_RETRY)
1100   3              {
1101   4                eepromCount++;                          // Increment number of attempts when NACK is received
1102   4                STA = 1;                            // Restart a new transfer
1103   4              }
1104   3              else
1105   3              {
1106   4                eepromCount = 0;
1107   4                STO = 1;
1108   4                SMB_BUSY = 0;
1109   4                FAIL = 1;
1110   4              } 
1111   3            }
1112   2            else
1113   2            {}
1114   2                break;
1115   2      
1116   2      //-------------------------------------------------------------------------------------------------------
1117   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1118   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1119   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1120   2      //-------------------------------------------------------------------------------------------------------
1121   2              case SMB_ADDR_R_TX_ACK_RX:
1122   2                if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1123   2                {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1124   3                    AA = 0;                                                   // Clear AA flag before data byte is rec
             -eived
1125   3                                                                              // send NACK signal to slave after byte 
             -is received
1126   3                }
1127   2                else
1128   2                {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 20  

1129   3                    AA = 1;                                                   // More than one byte in this transfer,
1130   3                                                                              // send ACK after byte is received
1131   3                }
1132   2                break;
1133   2      
1134   2      //-------------------------------------------------------------------------------------------------------
1135   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1136   2      //-------------------------------------------------------------------------------------------------------
1137   2              case SMB_ADDR_R_TX_NACK_RX:
1138   2            if(slaveAddr == MCU_SLAVE_ADDR)
1139   2            {
1140   3              if(slaveCount < MAX_NACK_RETRY)
1141   3              {
1142   4                slaveCount++;                         // Increment number of attempts when NACK is received
1143   4                STA = 1;                            // Restart transfer after receiving a NACK
1144   4              }
1145   3              else
1146   3              {
1147   4                slaveCount = 0;                         // Reset counter
1148   4                STO = 1;
1149   4                SMB_BUSY = 0;
1150   4                FAIL = 1;
1151   4              } 
1152   3            }
1153   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1154   2            {
1155   3              if(realTimeClockCount < MAX_NACK_RETRY)
1156   3              {
1157   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1158   4                STA = 1;                            // Restart a new transfer
1159   4              }
1160   3              else
1161   3              {
1162   4                realTimeClockCount = 0;
1163   4                STO = 1;
1164   4                SMB_BUSY = 0;
1165   4                FAIL = 1;
1166   4              } 
1167   3            }
1168   2            else if(slaveAddr == EEPROM_ADDR)
1169   2            {
1170   3              if(eepromCount < MAX_NACK_RETRY)
1171   3              {
1172   4                eepromCount++;                          // Increment number of attempts when NACK is received
1173   4                STA = 1;                            // Restart a new transfer
1174   4              }
1175   3              else
1176   3              {
1177   4                eepromCount = 0;
1178   4                STO = 1;
1179   4                SMB_BUSY = 0;
1180   4                FAIL = 1;
1181   4              } 
1182   3            }
1183   2            else
1184   2            {}
1185   2                break;
1186   2      
1187   2      //-------------------------------------------------------------------------------------------------------
1188   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1189   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 21  

1190   2      //-------------------------------------------------------------------------------------------------------
1191   2              case SMB_DATA_RX_ACK_TX:
1192   2            
1193   2            if(slaveAddr == MCU_SLAVE_ADDR)
1194   2            {
1195   3              if (RxCounter < numBytesRD)
1196   3                  {
1197   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1198   4                      AA = 1;                                                 // Send ACK to indicate byte received
1199   4                      RxCounter++;                                            // Increment the byte counter
1200   4                slaveReadDone = 0;                        // Mark start of slave read
1201   4                  }
1202   3                  else
1203   3                  {
1204   4                      AA = 0;                                                 // Send NACK to indicate last byte is re
             -ceived
1205   4                slaveReadDone = 1;                        // Mark end of slave read
1206   4                  }
1207   3            }
1208   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1209   2            {
1210   3              if(RxCounter < numBytesRD)
1211   3              {
1212   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1213   4                rtcReadDone = 0;
1214   4                
1215   4                AA = 1;                             // Send ACK to indicate byte received
1216   4                RxCounter++;                          // Increment the byte counter
1217   4              }
1218   3              else
1219   3              {
1220   4                rtcReadDone = 1;
1221   4                AA = 0;                             // Send NACK to indicate last byte is received
1222   4              }
1223   3            }
1224   2            else if(slaveAddr == EEPROM_ADDR)
1225   2            {
1226   3              if(RxCounter < numBytesRD)
1227   3              {
1228   4                eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1229   4                AA = 1;                             // Send ACK to indicate byte received
1230   4                RxCounter++;                          // Increment the byte counter
1231   4                eepromReadDone = 0;                       // Mark start of fram read
1232   4              }
1233   3              else
1234   3              {
1235   4                AA = 0;                             // Send NACK to indicate last byte is received
1236   4                eepromReadDone = 1;                       // Mark end of fram read
1237   4              }
1238   3            }
1239   2                break;
1240   2      
1241   2      //-------------------------------------------------------------------------------------------------------
1242   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1243   2      // For a READ: Read operation has completed.  Read data register and send STOP
1244   2      //-------------------------------------------------------------------------------------------------------
1245   2              case SMB_DATA_RX_NACK_TX:
1246   2            if(slaveAddr == MCU_SLAVE_ADDR)
1247   2            {
1248   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1249   3                  STO = 1;                              // Stop transfer
1250   3                  SMB_BUSY = 0;                           // Release SMB
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 22  

1251   3                  AA = 1;
1252   3              slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next transfer   
             -                                              
1253   3            }
1254   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1255   2            {
1256   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1257   3              rtcReadDone = 1;
1258   3      
1259   3              STO = 1;                              // Stop transfer
1260   3              SMB_BUSY = 0;                           // Release SMB
1261   3              AA = 1;                               // Send ACK to indicate byte received
1262   3            }
1263   2            else if(slaveAddr == EEPROM_ADDR)
1264   2            {
1265   3              eepromRx[RxCounter] = SMB0DAT;
1266   3              STO = 1;                              // Stop transfer
1267   3              SMB_BUSY = 0;                           // Release SMB
1268   3              AA = 1;
1269   3              eepromReadDone = 1;                         // Mark end of eeprom read      
1270   3            }
1271   2                break;
1272   2      
1273   2      //-------------------------------------------------------------------------------------------------------
1274   2      // Master Transmitter: Arbitration lost
1275   2      //-------------------------------------------------------------------------------------------------------
1276   2              case SMB_ARBITRATION_LOST:
1277   2                FAIL = 1;                                                     // Indicate failed transfer
1278   2                                                                              // and handle at end of ISR
1279   2                break;
1280   2      
1281   2      //-------------------------------------------------------------------------------------------------------
1282   2      // All other status codes invalid.  Reset communication
1283   2      //-------------------------------------------------------------------------------------------------------
1284   2              default:
1285   2                FAIL = 1;
1286   2                break;
1287   2         }
1288   1      //-------------------------------------------------------------------------------------------------------
1289   1      // If all failed, reset everything
1290   1      //-------------------------------------------------------------------------------------------------------
1291   1          if(FAIL)                                                            // If the transfer failed,
1292   1          {
1293   2              SMB0CN &= ~0x40;                                                  // Reset communication
1294   2              SMB0CN |= 0x40;
1295   2              STA = 0;
1296   2              STO = 0;
1297   2              AA = 0;
1298   2      
1299   2              SMB_BUSY = 0;                                                     // Free SMBus
1300   2      
1301   2              FAIL = 0;
1302   2                                                // Set to finish all pending processes
1303   2          slaveWriteDone = 1;                             // Mark end of slave write
1304   2          slaveReadDone = 1;                              // Mark end of slave read
1305   2              rtcWriteDone = 1;
1306   2          rtcReadDone = 1;
1307   2          eepromWriteDone = 1;                            // Mark end of eeprom write
1308   2          eepromReadDone = 1;                             // Mark end of eeprom read
1309   2        }
1310   1      
1311   1        SI = 0;                                                             // Clear interrupt flag
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 23  

1312   1      }
1313          
1314          //-------------------------------------------------------------------------------------------------------
1315          // Function Name: setClockControl
1316          // Return Value: None 
1317          // Parmeters: None
1318          // Function Description: This function sets values to the real time clock control register
1319          // Check DS3232 documentation for more details of this this control register
1320          //-------------------------------------------------------------------------------------------------------
1321          void setClockControl(void)
1322          {
1323   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1324   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
1325   1        writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
1326   1      }
1327                            
1328          //-------------------------------------------------------------------------------------------------------
1329          // Function Name: setClock
1330          // Return Value: None 
1331          // Parmeters: None
1332          // Function Description: This function sets the new values to the real time clock
1333          //-------------------------------------------------------------------------------------------------------
1334          void setClock(void)
1335          { 
1336   1        unsigned char hoursAux;
1337   1        
1338   1        sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to arr
             -ay before writing
1339   1        sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... are a
             -lready converted to BCD
1340   1        sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1341   1        sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1342   1        sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1343   1        sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1344   1        
1345   1        hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1346   1      
1347   1        hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1348   1        
1349   1        if(amPm == 'P')
1350   1        {
1351   2           hoursAux = hoursAux | 0x60;                          // Set AM/PM bit --> PM mode
1352   2        }
1353   1        else if(amPm == 'A')
1354   1        {
1355   2           hoursAux = hoursAux & 0x5F;                          // Clear AM/PM bit --> AM mode
1356   2        }
1357   1        
1358   1        sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1359   1        
1360   1        writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes to R
             -TC
1361   1      
1362   1        //resetAllDisplayCounters();                              // Update new values on screen
1363   1      }     
1364          
1365          //-------------------------------------------------------------------------------------------------------
1366          // Function Name: getClockData()
1367          // Return Value: None 
1368          // Parmeters: None
1369          // Function Description: This function gets the new values from the real time clock
1370          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 24  

1371          void getClockData()
1372          {
1373   1        static unsigned char previousMonth = 0;
1374   1        static unsigned char previousDate = 0;
1375   1        static unsigned char previousYear = 0;
1376   1        static unsigned char previousHours = 0;
1377   1        static unsigned char previousMinutes = 0;
1378   1        static unsigned char previousSeconds = 0;
1379   1        
1380   1        unsigned int currentIndex = 0;
1381   1        unsigned char tempHours;
1382   1        
1383   1        readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1384   1      
1385   1        seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal for s
             -econds (1 byte)
1386   1        minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal for m
             -inutes (1 byte)
1387   1      
1388   1        tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/PM
1389   1      
1390   1        if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1391   1        {
1392   2          timeMode = TWELVE_HR_MODE;
1393   2      
1394   2          if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
1395   2          {
1396   3            amPm = 'P';
1397   3          }
1398   2          else
1399   2          {
1400   3              amPm = 'A';
1401   3          }
1402   2        }
1403   1        else
1404   1        {
1405   2          timeMode = TWENTY_FOUR_HR_MODE;
1406   2        }
1407   1      
1408   1        hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore others)
1409   1      
1410   1        if(hours == 12)
1411   1        {
1412   2          if(amPm == 'A')
1413   2          {
1414   3            hours24 = 0;
1415   3          }
1416   2          else
1417   2          {
1418   3            hours24 = hours;
1419   3          } 
1420   2        }
1421   1        else
1422   1        {
1423   2          if(amPm == 'P')
1424   2          {
1425   3            hours24 = hours + 12;                           // Twenty four hour format if PM
1426   3          }
1427   2          else
1428   2          {
1429   3            hours24 = hours;                              // Twenty four hour format if AM
1430   3          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 25  

1431   2        }
1432   1      
1433   1        day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day (1 
             -byte)
1434   1        date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for date (
             -1 byte)
1435   1        month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for mont
             -h (1 byte)
1436   1        year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for year (
             -1 byte)
1437   1      
1438   1        if(month != previousMonth || date != previousDate || year != previousYear)
1439   1        {
1440   2          monthDateYearUpdated = SET;   
1441   2        }
1442   1        if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1443   1        {
1444   2          timeUpdated = SET;
1445   2        }
1446   1      
1447   1        if(amPm == 'P')
1448   1        {
1449   2          currentIndex = ((12 + hours) * 60) + minutes;
1450   2        }
1451   1        else if(amPm == 'A')
1452   1        {
1453   2          if(hours == 12)
1454   2          {
1455   3            hours = 0;
1456   3          }
1457   2          
1458   2          currentIndex = (hours * 60) + minutes;
1459   2        }
1460   1        else
1461   1        {}
1462   1      
1463   1        minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1464   1        hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1465   1      
1466   1        previousDate = date;
1467   1        previousMonth = month;
1468   1        previousYear = year;
1469   1        previousHours = hours;
1470   1        previousMinutes = minutes;
1471   1        previousSeconds = seconds;
1472   1      }
1473          
1474          //-------------------------------------------------------------------------------------------------------
1475          // Function Name: moveDateTimeUp
1476          // Return Value: None 
1477          // Parmeters: None
1478          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1479          //-------------------------------------------------------------------------------------------------------
1480          void moveDateTimeUp(void)
1481          {
1482   1        char str[SPRINTF_SIZE];
1483   1        
1484   1        if(realTimeClockItems == MONTH_ADJUST)
1485   1        {
1486   2          adjustedMonth++;
1487   2          monthUpdated = SET;
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 26  

1488   2      
1489   2          if(adjustedMonth > 12)
1490   2          {
1491   3            adjustedMonth = 1;                              // Roll over
1492   3          }
1493   2      
1494   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1495   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1496   2        }
1497   1        else if(realTimeClockItems == DATE_ADJUST)
1498   1        {
1499   2          adjustedDate++;
1500   2          dateUpdated = SET;
1501   2      
1502   2          if(adjustedDate > 31)
1503   2          {
1504   3            adjustedDate = 1;                             // Roll over
1505   3          }
1506   2      
1507   2          sprintf(str, "%bu   ", adjustedDate);
1508   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1509   2        }
1510   1        else if(realTimeClockItems == YEAR_ADJUST)
1511   1        {
1512   2          adjustedYear++;
1513   2          yearUpdated = SET;
1514   2      
1515   2          if(adjustedYear > 99)
1516   2          {
1517   3            adjustedYear = 99;
1518   3          }
1519   2      
1520   2          sprintf(str, "20%02bu", adjustedYear);
1521   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1522   2        }
1523   1        else if(realTimeClockItems == HOUR_ADJUST)
1524   1        {
1525   2          adjustedHours++;
1526   2          hoursUpdated = SET;
1527   2      
1528   2          if(adjustedHours > 12)
1529   2          {
1530   3            adjustedHours = 1;                              // Roll over
1531   3          }
1532   2      
1533   2          sprintf(str, "%bu   ", adjustedHours);
1534   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1535   2        }
1536   1        else if(realTimeClockItems == MINUTE_ADJUST)
1537   1        {
1538   2          adjustedMinutes++;
1539   2          minutesUpdated = SET;
1540   2      
1541   2          if(adjustedMinutes > 59)
1542   2          {
1543   3            adjustedMinutes = 0;
1544   3          }
1545   2      
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 27  

1546   2          sprintf(str, "%bu   ", adjustedMinutes);
1547   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1548   2        }
1549   1        else if(realTimeClockItems == AMPM_ADJUST)
1550   1        {
1551   2          if(adjustedAmPm == 'P')
1552   2          {
1553   3            adjustedAmPm = 'A';
1554   3          }
1555   2          else if(adjustedAmPm == 'A')
1556   2          {
1557   3            adjustedAmPm = 'P';
1558   3          }
1559   2          else
1560   2          {}
1561   2      
1562   2          amPmUpdated = SET;
1563   2      
1564   2          sprintf(str, "%cM  ", adjustedAmPm);
1565   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1566   2        }
1567   1        else
1568   1        {}
1569   1      }
1570          
1571          //-------------------------------------------------------------------------------------------------------
1572          // Function Name: moveDateTimeDown
1573          // Return Value: None 
1574          // Parmeters: None
1575          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1576          //-------------------------------------------------------------------------------------------------------
1577          void moveDateTimeDown(void)
1578          {
1579   1        char str[SPRINTF_SIZE];
1580   1      
1581   1        if(realTimeClockItems == MONTH_ADJUST)
1582   1        {
1583   2          adjustedMonth--;
1584   2            monthUpdated = SET;
1585   2      
1586   2          if(adjustedMonth < 1)
1587   2          {
1588   3            adjustedMonth = 12;                             // Roll over to hour 12
1589   3          }
1590   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1591   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1592   2        }
1593   1        else if(realTimeClockItems == DATE_ADJUST)
1594   1        {
1595   2          adjustedDate--;
1596   2          dateUpdated = SET;
1597   2      
1598   2          if(adjustedDate < 1)
1599   2          {
1600   3            adjustedDate = 31;                              // Roll over to day 31
1601   3          }
1602   2      
1603   2          sprintf(str, "%bu   ", adjustedDate);
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 28  

1604   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1605   2        }
1606   1        else if(realTimeClockItems == YEAR_ADJUST)
1607   1        {
1608   2          if(adjustedYear > 0)
1609   2          {
1610   3            adjustedYear--;                               // Check if it is greater than 0 before decrementing                        
1611   3          }                                       // to avoid a negative number
1612   2          else
1613   2          {
1614   3            adjustedYear = 0;                             // Roll over to 99
1615   3          }
1616   2          
1617   2          yearUpdated = SET;
1618   2      
1619   2          sprintf(str, "20%02bu", adjustedYear);
1620   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1621   2        }
1622   1        else if(realTimeClockItems == HOUR_ADJUST)
1623   1        {
1624   2          if(adjustedHours > 0)
1625   2          {
1626   3            adjustedHours--;                              // Check if it is greater than 0 before decrementing
1627   3          }                                       // to avoid a negative number
1628   2          else
1629   2          {
1630   3            adjustedHours = 12;
1631   3          }
1632   2      
1633   2          hoursUpdated = SET;
1634   2      
1635   2          sprintf(str, "%bu   ", adjustedHours);
1636   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1637   2        }
1638   1        else if(realTimeClockItems == MINUTE_ADJUST)
1639   1        {
1640   2          if(adjustedMinutes > 0)
1641   2          {
1642   3            adjustedMinutes--;                              // Check if it is greater than 0 before decrementing
1643   3          }                                       // to avoid a negative number
1644   2          else
1645   2          {
1646   3            adjustedMinutes = 59;
1647   3          }
1648   2      
1649   2          minutesUpdated = SET;
1650   2      
1651   2          sprintf(str, "%bu   ", adjustedMinutes);
1652   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1653   2        }
1654   1        else if(realTimeClockItems == AMPM_ADJUST)
1655   1        {
1656   2          if(adjustedAmPm == 'P')
1657   2          {
1658   3            adjustedAmPm = 'A';
1659   3          }
1660   2          else if(adjustedAmPm == 'A')
1661   2          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 29  

1662   3            adjustedAmPm = 'P';
1663   3          }
1664   2          else
1665   2          {}
1666   2      
1667   2          amPmUpdated = SET;
1668   2      
1669   2          sprintf(str, "%cM  ", adjustedAmPm);
1670   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1671   2        }
1672   1        else
1673   1        {}
1674   1      }
1675          
1676          //-------------------------------------------------------------------------------------------------------
1677          // Function Name: enterDateTime
1678          // Return Value: None 
1679          // Parmeters: None
1680          // Function Description: This function confirms the date or time set by the user on the touch screen
1681          //-------------------------------------------------------------------------------------------------------
1682          void enterDateTime(void)
1683          {
1684   1        char str[SPRINTF_SIZE];
1685   1        
1686   1        realTimeClockItems++;                               // Move to next item
1687   1        
1688   1        if(realTimeClockItems == MONTH_ADJUST)
1689   1        {
1690   2          monthUpdated = SET;
1691   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1692   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1693   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1694   2        }
1695   1        else if(realTimeClockItems == DATE_ADJUST)
1696   1        {
1697   2          dateUpdated = SET;
1698   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1699   2          sprintf(str, "%bu   ", adjustedDate);
1700   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1701   2        }
1702   1        else if(realTimeClockItems == YEAR_ADJUST)
1703   1        {
1704   2          yearUpdated = SET;
1705   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1706   2          sprintf(str, "20%02bu", adjustedYear);
1707   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1708   2        }
1709   1        else if(realTimeClockItems == HOUR_ADJUST)
1710   1        {
1711   2          hoursUpdated = SET;
1712   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1713   2          sprintf(str, "%bu   ", adjustedHours);
1714   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 30  

1715   2        }
1716   1        else if(realTimeClockItems == MINUTE_ADJUST)
1717   1        {
1718   2          minutesUpdated = SET;
1719   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1720   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1721   2          sprintf(str, "%bu   ", adjustedMinutes);
1722   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1723   2        }
1724   1        else if(realTimeClockItems == AMPM_ADJUST)
1725   1        {
1726   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1727   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1728   2          sprintf(str, "%cM  ", adjustedAmPm);
1729   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1730   2        }
1731   1        else if(realTimeClockItems == DONE_ADJUST)
1732   1        {
1733   2          amPmUpdated = SET;                                // Set it if user explicitly press enter button
1734   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1735   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPL
             -AY_Y);
1736   2        }
1737   1        else if(realTimeClockItems == ROLL_OVER_ADJUST)
1738   1        {
1739   2          realTimeClockItems = MONTH_ADJUST;                        // Set it for next round of real time clock items
1740   2          monthUpdated = SET;
1741   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1742   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1743   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1744   2        }
1745   1        else
1746   1        {}
1747   1      }
1748          
1749          //-------------------------------------------------------------------------------------------------------
1750          // Function Name: setClockOnScreen
1751          // Return Value: None 
1752          // Parmeters: None
1753          // Function Description: This function sets the real time clock on the touch screen
1754          //-------------------------------------------------------------------------------------------------------
1755          void setClockOnScreen(void)
1756          {   
1757   1        unsigned char hoursAux;
1758   1        
1759   1        if(monthUpdated == SET)
1760   1        {
1761   2          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);    // Get updated month from us
             -er on screen
1762   2          writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);             // Set month only (1 byte)
1763   2          monthUpdated = CLEAR;                             //Clear flag after writing to real time clock                         
1764   2        }
1765   1        
1766   1        if(dateUpdated == SET)
1767   1        {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 31  

1768   2          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);    // Get updated date from user 
             -on screen
1769   2          writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);              // Set date only (1 byte)
1770   2          dateUpdated = CLEAR;
1771   2        }
1772   1      
1773   1        if(yearUpdated == SET)
1774   1        {
1775   2          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);    // Get updated year from user 
             -on screen
1776   2          writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);              // Set year only (1 byte)
1777   2          yearUpdated = CLEAR;
1778   2        }
1779   1      
1780   1        if(hoursUpdated == SET || amPmUpdated == SET)
1781   1        {
1782   2          hoursAux = convertDecimalToBCD(adjustedHours);                  // Get updated hours from user on screen
1783   2          
1784   2          if(amPmUpdated == SET)
1785   2          {
1786   3            amPm = adjustedAmPm;                            // Set updated amPm from user on screen
1787   3          
1788   3            hoursAux = hoursAux | 0x40;                         // Set 12/24 bit --> 12 hour mode
1789   3            
1790   3            if(adjustedAmPm == 'P')
1791   3            {                                 
1792   4              hoursAux = hoursAux | 0x60;                       // Set AM/PM bit --> PM mode
1793   4            }
1794   3            else if(adjustedAmPm == 'A')
1795   3            {                                 
1796   4              hoursAux = hoursAux & 0x5F;                       // Clear AM/PM bit --> AM mode
1797   4            }
1798   3            else
1799   3            {}
1800   3      
1801   3            amPmUpdated = CLEAR;
1802   3          }
1803   2          
1804   2          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1805   2          writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);             // Set hours only (1 byte)
1806   2          hoursUpdated = CLEAR; 
1807   2        }
1808   1      
1809   1        if(minutesUpdated == SET)
1810   1        {
1811   2          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated minutes fr
             -om user on screen
1812   2          writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);             // Set minutes only (1 byte)
1813   2          minutesUpdated = CLEAR;
1814   2        }
1815   1      
1816   1        realTimeClockItems = MONTH_ADJUST;                          // Set starting item = Month for adjustment
1817   1      
1818   1        getClockData();                                     // Get current month, date, year set by user
1819   1      
1820   1        //clockSetupDisplayRepeat = 0;                            // Display clock updates on screen                                    // Syste
             -m goes back to main page          
1821   1      }
1822          
1823          //-------------------------------------------------------------------------------------------------------
1824          // Function Name: resetClock
1825          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 32  

1826          // Parmeters: None
1827          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1828          //-------------------------------------------------------------------------------------------------------
1829          void resetClock(void)
1830          {
1831   1        seconds = 0;
1832   1        minutes = 0;
1833   1        hours = 0;
1834   1        amPm = 'P';
1835   1        day = 1;
1836   1        date = 1;
1837   1        month = 1;
1838   1        year = 0;
1839   1        century = 0;
1840   1        timeMode = 1;
1841   1      
1842   1        setClock();                                             // Set real time clock
1843   1      }
1844          
1845          //-------------------------------------------------------------------------------------------------------
1846          // Function Name: convertDecimalToBCD
1847          // Return Value: bcd 
1848          // Parmeters: decimal
1849          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1850          //-------------------------------------------------------------------------------------------------------
1851          unsigned char convertDecimalToBCD(unsigned char decimal)
1852          {
1853   1        unsigned char bcd;
1854   1      
1855   1        bcd = (decimal / 10) << 4;                              // Get upper 4 bits
1856   1        bcd = bcd | (decimal % 10);                             // Get a BCD
1857   1      
1858   1        return bcd;
1859   1      }
1860          
1861          //-------------------------------------------------------------------------------------------------------
1862          // Function Name: convertBCDToDecimal
1863          // Return Value: decimal value 
1864          // Parmeters: bcd
1865          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1866          //-------------------------------------------------------------------------------------------------------
1867          unsigned char convertBCDToDecimal(unsigned char bcd)
1868          {
1869   1        unsigned char decimal;
1870   1      
1871   1        decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
1872   1                                                  // 8 bit number
1873   1        return decimal;
1874   1      }
1875          
1876          //-------------------------------------------------------------------------------------------------------
1877          // Function Name: displayClock
1878          // Return Value: None 
1879          // Parmeters: None
1880          // Function Description: This function displays clock data on the touch screen
1881          // The clock format is MM/DD/YYYY hour/minute/second
1882          //-------------------------------------------------------------------------------------------------------
1883          void displayClock(void)
1884          {
1885   1        char str[SPRINTF_SIZE];
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 33  

1886   1        
1887   1        //if(screen == MAIN_PAGE)
1888   1        //{
1889   1              getClockData();
1890   1      
1891   1              sprintf(str, "%s %02bu, 20%02bu %s", monthOfYear[month], date, year, dayOfWeek[day]);
1892   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
1893   1              monthDateYearUpdated = CLEAR;
1894   1              
1895   1              sprintf(str, "%2bu : %02bu : %02bu %cM ", hours, minutes, seconds, amPm);
1896   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
1897   1        //}
1898   1        /*else if(screen == CLOCK_SETUP_PAGE)
1899   1        {
1900   1          if(buttonPressed == CLEAR)
1901   1          {
1902   1            getClockData();
1903   1        
1904   1            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1905   1            displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y);
1906   1            monthDateYearUpdated = CLEAR;
1907   1      
1908   1            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1909   1            displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y);
1910   1            timeUpdated = CLEAR;
1911   1          }
1912   1        }*/
1913   1      }
1914          
1915          //-------------------------------------------------------------------------------------------------------
1916          // Main
1917          //-------------------------------------------------------------------------------------------------------
1918          // Control functions
1919          void bar_load(); // function code == 11
1920          void login_page_load(); // function code == 21
1921          void login_attempts(); // function code == 22
1922          void login_clear_stars(); // function code == 23
1923          void login_disp_1_star(); // function code == 24
1924          void login_disp_2_star(); // function code == 25
1925          void login_disp_3_star(); // function code == 26
1926          void login_disp_4_star(); // function code == 27
1927          void locked_page_load(); // function code == 31
1928          void update_wait_time(); // function code == 32
1929          void login_clear_disp(); // function code == 33
1930          void main_page_load();  // function code == 40
1931          void temp_page_load();  // function code == 41
1932          void motor_page_load(); // function code == 42
1933          void laser_page_load(); // function code == 43
1934          void setting_page_load(); // function code == 44
1935          void c_to_f();  // function code == 50
1936          void f_to_c();  // function code == 51
1937          void add_point(); // function code == 52
1938          void game_start();  // function code == 53
1939          void brightness_setting();  // function code == 54
1940          void time_setting();  // function code == 55
1941          void set_clock(); // function code == 56
1942          
1943          
1944          int get_function_code();
1945          int passcode[4]={0};
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 34  

1946          int is_locked_out=0;
1947          int attempts=5;
1948          int is_in_temp_page=0;
1949          int is_in_motor_page=0;
1950          int is_in_game=0;
1951          int is_in_laser_page=0;
1952          int is_in_main_page=0;
1953          int is_in_setting_page=0;
1954          int is_in_c=1;
1955          int _delay=0;
1956          char userID[64];
1957          int stones=20;
1958          int duration=2000;
1959          int point=0;
1960          int brightness=120;
*** WARNING C231 IN LINE 1960 OF ..\mc_code\with_real_time_clock\main.c: 'brightness': redefinition
1961          int c=20;
1962          int set_time=0;
1963          double dayweek;
1964          int select=0;
1965          int clock_value;
1966          
1967          void main()
1968          {
1969   1        int i = 0;
1970   1          char str[SPRINTF_SIZE];
1971   1          int testCounter = 0;
1972   1          
1973   1          disableWatchdog();
1974   1          systemClockInit();
1975   1        portInit();
1976   1        enableInterrupts();
1977   1        uart0Init();
1978   1          smbInit();
1979   1          timer3Init();
1980   1          
1981   1          tsLastCharGone = 1;
1982   1          tsTxOut = tsTxIn = 0;
1983   1          tsTxEmpty = 1;
1984   1          
1985   1        while(1)
1986   1        {
1987   2          //------------------clock display in main page------------------
1988   2              if(_delay%10000==0 && is_in_main_page)
1989   2              {
1990   3              getClockData();   
1991   3              sprintf(str, "%2bu:%02bu%cM ", hours, minutes, amPm);
1992   3              displayText("000000", "F7F9F8", 2, str, 160, 0);
1993   3              sprintf(str, "20%02bu/%02bu/%02bu", year, month, date);
1994   3              displayText("000000", "F7F9F8", 2, str, 150, 20);
1995   3              monthDateYearUpdated = CLEAR;
1996   3              }
1997   2          //------------------time display------------------
1998   2              if(is_in_setting_page && _delay%10000==0)
1999   2              {
2000   3                displayClock();                             // Display clock data on the screen
2001   3                switch(select)
2002   3                {
2003   4                  case 0: break;
2004   4                  case 1: sprintf(str, "xi 16 163 393\r"); sendCommand(str); break;
2005   4                  case 2: sprintf(str, "xi 16 237 393\r"); sendCommand(str); break;
2006   4                  case 3: sprintf(str, "xi 17 318 393\r"); sendCommand(str); break;
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 35  

2007   4                  case 4: sprintf(str, "xi 16 163 437\r"); sendCommand(str); break;
2008   4                  case 5: sprintf(str, "xi 16 258 437\r"); sendCommand(str); break;
2009   4                  case 6: sprintf(str, "xi 16 362 437\r"); sendCommand(str); break;
2010   4                  case 7: break;
2011   4                  default: break;
2012   4                }
2013   3          //      sprintf(str, "%s", amPm);
2014   3          //      displayText("000000", "FFFFFF", 4, str, 123, 0);
2015   3          /*    if(!set_time)
2016   3              {
2017   3                
2018   3                seconds=0;
2019   3                minutes=23;
2020   3                hours=4;
2021   3                amPm='A';
2022   3                date=27;
2023   3                month=11;
2024   3                year=17;
2025   3                century=20;
2026   3                timeMode=1;
2027   3                if(month==1 || month==2)                day=(date+1+2*(month+12)+3*((month+12)+1)/5+(year-1)+(year-1)/4-(year
             --1)/100+(year-1)/400)%7;
2028   3                else                                    day=(date+1+2*month+3*(month+1)/5+year+year/4-year/100+year/400)%7;
2029   3                setClock();
2030   3                set_time=1;
2031   3              }*/
2032   3              }
2033   2          //-----------------game display-------------------
2034   2              if(is_in_motor_page && _delay%10000==0)
2035   2              {
2036   3                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2037   3                  c=roomTemp;       
2038   3                  if(is_in_c)
2039   3                  {
2040   4                    sprintf(str, "bodyC:%d", c);
2041   4                    displayText("000000", "FFFFFF", 2, str, 365,-4);
2042   4                  }
2043   3                  else
2044   3                  {
2045   4                    sprintf(str, "bodyF:%d", c*9/5+32);
2046   4                    displayText("000000", "FFFFFF", 2, str, 365,-4);              
2047   4                  }
2048   3                  if(is_in_game)
2049   3                  {
2050   4                    if(point<10)
2051   4                    {
2052   5                      sprintf(str, "%d", point);
2053   5                      displayText("000000", "FF0000", 6, str, 305,20);
2054   5                    }
2055   4                    else
2056   4                    {
2057   5                      sprintf(str, "%d", point);
2058   5                      displayText("000000", "FF0000", 6, str, 290,20);
2059   5                    }
2060   4                  }
2061   3      
2062   3              }
2063   2              if(is_in_game && _delay%50000==0)
2064   2              { 
2065   3                  if(stones<=20 && stones>15) 
2066   3                  {
2067   4                    if(c<20)  duration=700;
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 36  

2068   4                    else      duration=700+((c-20)*130);
2069   4                    sprintf(str, "STAGE 1");
2070   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2071   4                  }
2072   3                  else if(stones<=15 && stones>10)  
2073   3                  {
2074   4                    if(c<20)  duration=500;
2075   4                    else      duration=500+((c-20)*100);
2076   4                    sprintf(str, "STAGE 2");
2077   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2078   4                  }
2079   3                  else if(stones<=10 && stones>5) 
2080   3                  {
2081   4                    if(c<20)  duration=300;
2082   4                    else      duration=300+((c-20)*70);
2083   4                    sprintf(str, "STAGE 3");
2084   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2085   4                  }
2086   3                  else if(stones<=5 && stones>0)    
2087   3                  {
2088   4                    if(c<20)  duration=100;
2089   4                    else      duration=100+((c-20)*40);
2090   4                    sprintf(str, "STAGE 4");
2091   4                    displayText("000000", "FFFFFF", 4, str, 260,80);
2092   4                  }
2093   3                  if(stones<=0) 
2094   3                  {
2095   4                    is_in_game=0;
2096   4                    if(point<10)
2097   4                    {
2098   5                      sprintf(str, "m lose %2bu %02bu %cM\r",  hours, minutes, amPm);
2099   5                      sendCommand(str);
2100   5                    }
2101   4                    else
2102   4                    {
2103   5                      sprintf(str, "m win %s\r", userID);
2104   5                      sendCommand(str);
2105   5                    }
2106   4                  }
2107   3                  else
2108   3                  {
2109   4                    int number=(rand() % 10) +1;
2110   4                    switch (number)
2111   4                    {
2112   5                    case 1:
2113   5                    sprintf(str, "m stone_display 133 118 %d\r", duration);
2114   5                    sendCommand(str);
2115   5                    break;
2116   5                    case 2:
2117   5                    sprintf(str, "m stone_display 118 159 %d\r", duration);
2118   5                    sendCommand(str);
2119   5                    break;
2120   5                    case 3:
2121   5                    sprintf(str, "m stone_display 124 202 %d\r", duration);
2122   5                    sendCommand(str);
2123   5                    break;
2124   5                    case 4:
2125   5                    sprintf(str, "m stone_display 130 263 %d\r", duration);
2126   5                    sendCommand(str); 
2127   5                    break;
2128   5                    case 5:
2129   5                    sprintf(str, "m stone_display 150 300 %d\r", duration);
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 37  

2130   5                    sendCommand(str);
2131   5                    break;
2132   5                    case 6:
2133   5                    sprintf(str, "m stone_display 474 120 %d\r", duration);
2134   5                    sendCommand(str);
2135   5                    break;
2136   5                    case 7:
2137   5                    sprintf(str, "m stone_display 487 159 %d\r", duration);
2138   5                    sendCommand(str);
2139   5                    break;
2140   5                    case 8:
2141   5                    sprintf(str, "m stone_display 483 204 %d\r", duration);
2142   5                    sendCommand(str); 
2143   5                    break;
2144   5                    case 9:
2145   5                    sprintf(str, "m stone_display 480 266 %d\r", duration);
2146   5                    sendCommand(str);
2147   5                    break;
2148   5                    case 10:
2149   5                    sprintf(str, "m stone_display 452 306 %d\r", duration);
2150   5                    sendCommand(str); 
2151   5                    break;              
2152   5                    default:
2153   5                    break;
2154   5                    }
2155   4                    stones--;
2156   4                  }
2157   3              }
2158   2          //-----------------text animation display-------------------
2159   2              if(is_in_laser_page && _delay%2000==0)
2160   2              { 
2161   3                  sprintf(str, "m text_display\r");
2162   3                  sendCommand(str);
2163   3              }
2164   2          //-----------------temperature display-------------------
2165   2              if(is_in_temp_page && _delay%20000==0)
2166   2              { 
2167   3                if(is_in_c) //C
2168   3                {
2169   4                  //Left
2170   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2171   4                  sprintf(str, " %-5bu", roomTemp);
2172   4                  displayText("000000", "8D8989", 6, str, 208, 160);
2173   4                  //Right
2174   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2175   4                  sprintf(str, " %-5bu", roomTemp);
2176   4                  displayText("000000", "8D8989", 6, str, 338, 160);
2177   4                }
2178   3                else  //F
2179   3                {
2180   4                  //Left
2181   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2182   4                  sprintf(str, " %-5bu", roomTemp*9/5+32);
2183   4                  displayText("000000", "8D8989", 6, str, 208, 160);
2184   4                  //Right
2185   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP_1);
2186   4                  sprintf(str, " %-5bu", roomTemp*9/5+32);
2187   4                  displayText("000000", "8D8989", 6, str, 338, 160);
2188   4                }
2189   3              }
2190   2          //----------------------------------------------------------
2191   2              if (tsCommandReceived) {
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 38  

2192   3                  switch (get_function_code()) {
2193   4                      case 11: bar_load(); break;
2194   4                      case 21: login_page_load(); break;
2195   4                      case 22: login_attempts(); break;
2196   4                      case 23: login_clear_stars(); break;
2197   4                      case 24: login_disp_1_star(); break;
2198   4                      case 25: login_disp_2_star(); break;
2199   4                      case 26: login_disp_3_star(); break;
2200   4                      case 27: login_disp_4_star(); break;
2201   4                      case 40: main_page_load(); break;
2202   4                      case 41: temp_page_load(); break;
2203   4                      case 42: motor_page_load(); break;
2204   4                      case 43: laser_page_load(); break;
2205   4                      case 44: setting_page_load(); break;
2206   4                      case 50: c_to_f(); break;
2207   4                      case 51: f_to_c(); break;
2208   4                      case 52: add_point(); break;
2209   4                      case 53: game_start(); break;
2210   4                      case 54: brightness_setting(); break;
2211   4                      case 55: time_setting(); break;
2212   4                      case 56: set_clock(); break;
2213   4                      default: break;
2214   4                  }
2215   3              }
2216   2              _delay++;
2217   2        }
2218   1      }
2219          
2220          // Splash Page begin ==========
2221          
2222          // function code == 11
2223          void bar_load() {
2224   1          char str[64];
2225   1          sprintf(str, "m load_bar_full 220 275 100 03\r");
2226   1          sendCommand(str);
2227   1      }
2228          // Splash page end ============
2229          
2230          int get_function_code() {
2231   1          // TODO, receive commands from screen
2232   1          if(userCommand[0]=='l' && userCommand[1]=='o' && userCommand[2]=='a')
2233   1          {
2234   2            is_in_temp_page=0;
2235   2            is_in_motor_page=0;
2236   2            is_in_game=0;
2237   2            is_in_laser_page=0;
2238   2            is_in_setting_page=0;
2239   2            is_in_main_page=0;
2240   2            is_in_c=1;
2241   2            attempts==5;
*** WARNING C275 IN LINE 2241 OF ..\mc_code\with_real_time_clock\main.c: expression with possibly no effect
2242   2            is_locked_out=0;
2243   2            select=0;
2244   2            tsCommandReceived=0;
2245   2            return 11;
2246   2          }
2247   1          else if(userCommand[0]=='g' && userCommand[1]=='e' && userCommand[2]=='t' && userCommand[3]=='_')
2248   1          {
2249   2            tsCommandReceived=0;
2250   2            return 52;
2251   2          }
2252   1          else if(userCommand[0]=='s' && userCommand[1]=='t' && userCommand[2]=='a' && userCommand[3]=='r')
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 39  

2253   1          {
2254   2            tsCommandReceived=0;
2255   2            return 53;
2256   2          }
2257   1          else if(userCommand[0]=='l' && userCommand[1]=='2' && userCommand[2]=='4' && userCommand[3]=='1')
2258   1          {
2259   2            if      (userCommand[6]=='\0')  brightness=userCommand[5]-'0';
2260   2            else if (userCommand[7]=='\0')  brightness=(userCommand[5]-'0')*10 + userCommand[6]-'0';
2261   2            else                            brightness=(userCommand[5]-'0')*100 +(userCommand[6]-'0')*10 + userCommand[7]-'0';
2262   2            tsCommandReceived=0;
2263   2            return 54;
2264   2          }
2265   1          else if(userCommand[0]=='l' && userCommand[1]=='2' && userCommand[2]=='4' && userCommand[3]=='3')
2266   1          {
2267   2            if      (userCommand[6]=='\0')  clock_value=userCommand[5]-'0';
2268   2            else                            clock_value=(userCommand[5]-'0')*10 + userCommand[6]-'0';
2269   2            tsCommandReceived=0;
2270   2            return 56;
2271   2          }
2272   1          else if(userCommand[0]=='d' && userCommand[1]=='t' && userCommand[2]=='_')
2273   1          {
2274   2            switch (userCommand[3])
2275   2            {
2276   3                case 'M': select=1; break;
2277   3                case 'd': select=2; break;
2278   3                case 'y': select=3; break;
2279   3                case 'h': select=4; break;
2280   3                case 'm': select=5; break;
2281   3                case 's': select=6; break;
2282   3                case 'a': select=7; break;
2283   3                default: break;
2284   3            }
2285   2            tsCommandReceived=0;
2286   2            return 55;
2287   2          }
2288   1          else if(userCommand[0]=='e' && userCommand[1]=='n' && userCommand[2]=='d' && userCommand[3]=='l')
2289   1          {
2290   2            tsCommandReceived=0;
2291   2            return 21;
2292   2          }
2293   1          else if(userCommand[0]=='m' && userCommand[1]=='p' && userCommand[2]=='_' && userCommand[3]=='l' && user
             -Command[4]=='o')
2294   1          {
2295   2            tsCommandReceived=0;
2296   2            return 23;
2297   2          }
2298   1          else if(passcode[0]==0)
2299   1          {
2300   2            passcode[0]=userCommand[3]-'0';
2301   2            tsCommandReceived=0;
2302   2            return 24;
2303   2          }
2304   1          else if(passcode[1]==0)
2305   1          {
2306   2            passcode[1]=userCommand[3]-'0';
2307   2            tsCommandReceived=0;
2308   2            return 25;
2309   2          }
2310   1          else if(passcode[2]==0)
2311   1          {
2312   2            passcode[2]=userCommand[3]-'0';
2313   2            tsCommandReceived=0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 40  

2314   2            return 26;
2315   2          }
2316   1          else if(passcode[3]==0)
2317   1          {
2318   2            passcode[3]=userCommand[3]-'0';
2319   2            tsCommandReceived=0;
2320   2            return 27;
2321   2          }
2322   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='m' && userC
             -ommand[4]=='a')
2323   1          {
2324   2            tsCommandReceived=0;
2325   2            return 40;
2326   2          }
2327   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='t')
2328   1          {
2329   2            tsCommandReceived=0;
2330   2            return 41;
2331   2          }
2332   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='m' && userC
             -ommand[4]=='o')
2333   1          {
2334   2            tsCommandReceived=0;
2335   2            return 42;
2336   2          }
2337   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='l' && userC
             -ommand[4]=='a')
2338   1          {
2339   2            tsCommandReceived=0;
2340   2            return 43;
2341   2          }
2342   1          else if(userCommand[0]=='m' && userCommand[1]=='p'&& userCommand[2]=='_' && userCommand[3]=='s' && userC
             -ommand[4]=='e')
2343   1          {
2344   2            tsCommandReceived=0;
2345   2            return 44;
2346   2          }
2347   1              else if(userCommand[0]=='n' && userCommand[1]=='s'&& userCommand[2]=='_' && userCommand[3]=='f')
2348   1          {
2349   2            tsCommandReceived=0;
2350   2            return 50;
2351   2          }
2352   1              else if(userCommand[0]=='n' && userCommand[1]=='s'&& userCommand[2]=='_' && userCommand[3]=='c')
2353   1          {
2354   2            tsCommandReceived=0;
2355   2            return 51;
2356   2          }
2357   1          return 0;
2358   1      }
2359          
2360          // Login Page begin ===========
2361          
2362          // function code == 21
2363          void login_page_load() {
2364   1            char str[64];
2365   1            sprintf(str, "m display_login_page\r");
2366   1            sendCommand(str);
2367   1      }
2368          
2369          // function code == 22
2370          void login_attempts() {
2371   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 41  

2372   1      }
2373          
2374          // function code == 23
2375          void login_clear_stars() {
2376   1            char str[64];
2377   1            attempts=5;
2378   1            sprintf(userID, "");
2379   1            passcode[0]=0;
2380   1            passcode[1]=0;
2381   1            passcode[2]=0;
2382   1            passcode[3]=0;
2383   1            is_locked_out=0;
2384   1            is_in_main_page=0;
2385   1            sprintf(str, "m display_login_page\r");
2386   1            sendCommand(str);
2387   1      }
2388          
2389          // function code == 24
2390          void login_disp_1_star() {
2391   1          char str[64];
2392   1          sprintf(str, "m display_asterik_1\r");
2393   1          sendCommand(str);
2394   1      }
2395          
2396          // function code == 25
2397          void login_disp_2_star() {
2398   1          char str[64];
2399   1          sprintf(str, "m display_asterik_2\r");
2400   1          sendCommand(str);
2401   1      }
2402          
2403          // function code == 26
2404          void login_disp_3_star() {
2405   1          char str[64];
2406   1          sprintf(str, "m display_asterik_3\r");
2407   1          sendCommand(str);
2408   1      }
2409          
2410          // function code == 27
2411          void login_disp_4_star() {
2412   1          char str[64];
2413   1          sprintf(str, "m display_asterik_4\r");
2414   1          sendCommand(str);
2415   1          if(is_locked_out==0 && passcode[0]==1 && passcode[1]==2 && passcode[2]==3 && passcode[3]==4)
2416   1          {
2417   2            sprintf(userID, "J Lin");
2418   2            sprintf(str, "m set_uid %s\r", userID);
2419   2            sendCommand(str);
2420   2            sprintf(str, "m display_main_page\r");
2421   2            sendCommand(str);
2422   2            is_in_main_page=1;
2423   2          }
2424   1          else if(is_locked_out==0 && passcode[0]==9 && passcode[1]==9 && passcode[2]==9 && passcode[3]==9)
2425   1          {
2426   2            sprintf(userID, "S-H Yang");
2427   2            sprintf(str, "m set_uid %s\r", userID);
2428   2            sendCommand(str);
2429   2            sprintf(str, "m display_main_page\r");
2430   2            sendCommand(str);
2431   2            is_in_main_page=1;
2432   2          }
2433   1          else if(is_locked_out==0 && passcode[0]==1 && passcode[1]==1 && passcode[2]==1 && passcode[3]==1)
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 42  

2434   1          {
2435   2            sprintf(userID, "Y Li");
2436   2            sprintf(str, "m set_uid %s\r", userID);
2437   2            sendCommand(str);
2438   2            sprintf(str, "m display_main_page\r");
2439   2            sendCommand(str);
2440   2            is_in_main_page=1;
2441   2          }
2442   1          else if(is_locked_out==1 && passcode[0]==6 && passcode[1]==7 && passcode[2]==8 && passcode[3]==9)
2443   1          {
2444   2            sprintf(userID, "C Davila");
2445   2            sprintf(str, "m set_uid %s\r", userID);
2446   2            sendCommand(str);
2447   2            sprintf(str, "m display_main_page\r");
2448   2            sendCommand(str);
2449   2            is_in_main_page=1;
2450   2          }
2451   1          else
2452   1          {
2453   2            sprintf(str, "xi 40 0 0\r");
2454   2            sendCommand(str);
2455   2            sprintf(str, "xc all\r");
2456   2            sendCommand(str);
2457   2            sprintf(str, "w 1000\r");
2458   2            sendCommand(str);
2459   2            passcode[0]=0;
2460   2            passcode[1]=0;
2461   2            passcode[2]=0;
2462   2            passcode[3]=0;
2463   2            attempts--;
2464   2            if(attempts<=0)
2465   2            {
2466   3              is_locked_out=1;
2467   3              sprintf(str, "m display_locked_page\r");
2468   3              sendCommand(str);
2469   3            }
2470   2            else
2471   2            {
2472   3              sprintf(str, "m display_login_attempts_left %d\r", attempts);
2473   3              sendCommand(str);
2474   3            }
2475   2          }
2476   1      }
2477          // Login Page end =============
2478          
2479          // Locked out Page begin ======
2480          
2481          // function code == 31
2482          void locked_page_load() {
2483   1      
2484   1      }
2485          
2486          // function code == 32
2487          void update_wait_time() {
2488   1      
2489   1      }
2490          
2491          // function code == 33
2492          void login_clear_disp() {
2493   1      
2494   1      }
2495          // Locked out Page end ========
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 43  

2496          
2497          void main_page_load()
2498          {
2499   1            char str[64];
2500   1            is_in_temp_page=0;
2501   1            is_in_motor_page=0;
2502   1            is_in_game=0;
2503   1            is_in_laser_page=0;
2504   1            is_in_setting_page=0;
2505   1            select=0;
2506   1            sprintf(str, "m display_main_page\r");
2507   1            sendCommand(str);
2508   1            is_in_main_page=1;
2509   1      }
2510          // finction code == 40
2511          
2512          void temp_page_load()
2513          {
2514   1            char str[64];
2515   1            sprintf(str, "m display_temp_page\r");
2516   1            sendCommand(str);
2517   1            is_in_temp_page=1;
2518   1            is_in_main_page=0;
2519   1            if(is_in_c==0)
2520   1            {
2521   2              sprintf(str, "m temp_unit_f\r");
2522   2              sendCommand(str);
2523   2            }
2524   1            else
2525   1            {
2526   2              sprintf(str, "m temp_unit_c\r");
2527   2              sendCommand(str);
2528   2            }       
2529   1      }
2530          // finction code == 41
2531          
2532          void motor_page_load()
2533          {
2534   1            char str[64];
2535   1            point=0;
2536   1            stones=20;
2537   1            sprintf(str, "m display_game_page\r");
2538   1            sendCommand(str);
2539   1            is_in_motor_page=1;
2540   1            is_in_main_page=0;
2541   1      }
2542          // finction code == 42
2543          
2544          void laser_page_load()
2545          {
2546   1            char str[64];
2547   1            sprintf(str, "m display_laser_page\r");
2548   1            sendCommand(str);
2549   1            is_in_laser_page=1;
2550   1            is_in_main_page=0;
2551   1      
2552   1      }
2553          // finction code == 43
2554          
2555          void setting_page_load()
2556          {
2557   1            char str[64];
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 44  

2558   1            sprintf(str, "m display_settings_screen %d\r", brightness);
2559   1            sendCommand(str);
2560   1            is_in_setting_page=1;
2561   1            is_in_main_page=0;
2562   1      }
2563          // finction code == 44
2564          
2565          void c_to_f()
2566          {
2567   1        is_in_c=0;
2568   1      }
2569          // finction code == 50
2570          
2571          void f_to_c()
2572          {
2573   1        is_in_c=1;
2574   1      }
2575          // finction code == 51
2576          
2577          void add_point()
2578          {
2579   1        point++;
2580   1      }
2581          // finction code == 52
2582          
2583          void game_start()
2584          {
2585   1        point=0;
2586   1        stones=20;
2587   1        is_in_game=1;
2588   1      }
2589          // finction code == 53
2590          
2591          void brightness_setting()
2592          {
2593   1        char str[64];
2594   1        sprintf(str, "m adjust_brightness %d\r", brightness);
2595   1        sendCommand(str);
2596   1      /*  
2597   1        if(brightness<10)
2598   1        {
2599   1          sprintf(str, "  %d", brightness);
2600   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2601   1        }
2602   1        else if(brightness<100)
2603   1        {
2604   1          sprintf(str, " %d", brightness);
2605   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2606   1        }
2607   1        else
2608   1        {
2609   1          sprintf(str, "%d", brightness);
2610   1          displayText("000000", "F7F9F8", 3, str, 305,118);
2611   1        }
2612   1      */
2613   1      }
2614          // finction code == 54
2615          
2616          void time_setting()
2617          {
2618   1        char str[64];
2619   1        switch(select)
C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 45  

2620   1        {
2621   2            case 0: break;
2622   2            case 1: sprintf(str, "m display_date_time_slider %02bu 12 1\r", month); sendCommand(str); break;
2623   2            case 2: if(month==1 || month==3 ||month==5 || month==7 ||month==8 || month==10 || month==12)
2624   2                    {
2625   3                      sprintf(str, "m display_date_time_slider %02bu 31 1\r", date); sendCommand(str); break;
2626   3                    }
2627   2                    else if(month==4 || month==6 ||month==9 || month==11)
2628   2                    {
2629   3                      sprintf(str, "m display_date_time_slider %02bu 30 1\r", date); sendCommand(str); break;
2630   3                    }
2631   2                    else if(month==2 && year%4==0)
2632   2                    {
2633   3                      sprintf(str, "m display_date_time_slider %02bu 29 1\r", date); sendCommand(str); break;
2634   3                    }
2635   2                    else
2636   2                    {
2637   3                      sprintf(str, "m display_date_time_slider %02bu 28 1\r", date); sendCommand(str); break;
2638   3                    }
2639   2            case 3: sprintf(str, "m display_date_time_slider %02bu 99 0\r", year); sendCommand(str); break;
2640   2            case 4: sprintf(str, "m display_date_time_slider %02bu 12 1\r", hours); sendCommand(str); break;
2641   2            case 5: sprintf(str, "m display_date_time_slider %02bu 59 0\r", minutes); sendCommand(str); break;
2642   2            case 6: sprintf(str, "m display_date_time_slider %02bu 59 0\r", seconds); sendCommand(str); break;
2643   2            case 7: if(amPm=='P')
2644   2                    {
2645   3                      amPm='A'; 
2646   3                    }
2647   2                    else
2648   2                    {
2649   3                      amPm='P'; 
2650   3                    }
2651   2                    setClock(); 
2652   2                    break;
2653   2            default: break;
2654   2        }
2655   1      
2656   1      }
2657          // finction code == 55
2658          
2659          void set_clock()
2660          {
2661   1        char str[64];
2662   1        switch(select)
2663   1        {
2664   2            case 0: break;
2665   2            case 1: month=clock_value; break;
2666   2            case 2: date=clock_value; break;
2667   2            case 3: year=clock_value; break;
2668   2            case 4: hours=clock_value; break;
2669   2            case 5: minutes=clock_value; break;
2670   2            case 6: seconds=clock_value; break;
2671   2            case 7: break;
2672   2            default: break;
2673   2        }
2674   1        if(month==1 || month==2)                day=(date+1+2*(month+12)+3*((month+12)+1)/5+(year-1)+(year-1)/4-(year-1)/
             -100+(year-1)/400)%7;
2675   1        else                                    day=(date+1+2*month+3*(month+1)/5+year+year/4-year/100+year/400)%7;
2676   1        setClock();
2677   1      }
*** WARNING C280 IN LINE 2661 OF ..\mc_code\with_real_time_clock\main.c: 'str': unreferenced local variable
2678          // finction code == 56

C51 COMPILER V9.56.0.0   MAIN                                                              11/27/2017 09:34:21 PAGE 46  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11935    ----
   CONSTANT SIZE    =   1687    ----
   XDATA SIZE       =   3619    1716
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
